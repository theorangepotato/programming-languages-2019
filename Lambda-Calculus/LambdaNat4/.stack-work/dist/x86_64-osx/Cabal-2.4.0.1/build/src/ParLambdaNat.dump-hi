
==================== FINAL INTERFACE ====================
2019-09-08 07:08:51.030381 UTC

interface LambdaNat-0.1.0.0-4B7roTwwXlI2zWJKCli09t:ParLambdaNat 8064
  interface hash: a010d848bdf3aeb17073e33c279bc174
  ABI hash: 235329d20196baff028de2633357f771
  export-list hash: 427350c1d95b33fd80d78807bebed545
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 64b15dc763247db9f2b7005aec11540e
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  ParLambdaNat.happyAccept
  ParLambdaNat.happyActOffsets
  ParLambdaNat.happyAdjustOffset
  ParLambdaNat.happyCheck
  ParLambdaNat.happyDefActions
  ParLambdaNat.happyDoAction
  ParLambdaNat.happyDoSeq
  ParLambdaNat.happyDontSeq
  ParLambdaNat.happyDrop
  ParLambdaNat.happyDropStk
  ParLambdaNat.happyError
  ParLambdaNat.happyError'
  ParLambdaNat.happyError_
  ParLambdaNat.happyExpList
  ParLambdaNat.happyExpListPerState
  ParLambdaNat.happyFail
  ParLambdaNat.happyGoto
  ParLambdaNat.happyGotoOffsets
  ParLambdaNat.happyIn10
  ParLambdaNat.happyIn11
  ParLambdaNat.happyIn12
  ParLambdaNat.happyIn13
  ParLambdaNat.happyIn14
  ParLambdaNat.happyIn15
  ParLambdaNat.happyIn16
  ParLambdaNat.happyIn17
  ParLambdaNat.happyInTok
  ParLambdaNat.happyLt
  ParLambdaNat.happyMonad2Reduce
  ParLambdaNat.happyMonadReduce
  ParLambdaNat.happyNewToken
  ParLambdaNat.happyOut10
  ParLambdaNat.happyOut11
  ParLambdaNat.happyOut12
  ParLambdaNat.happyOut13
  ParLambdaNat.happyOut14
  ParLambdaNat.happyOut15
  ParLambdaNat.happyOut16
  ParLambdaNat.happyOut17
  ParLambdaNat.happyOutTok
  ParLambdaNat.happyParse
  ParLambdaNat.happyReduce
  ParLambdaNat.happyReduceArr
  ParLambdaNat.happyReduce_10
  ParLambdaNat.happyReduce_11
  ParLambdaNat.happyReduce_12
  ParLambdaNat.happyReduce_13
  ParLambdaNat.happyReduce_14
  ParLambdaNat.happyReduce_15
  ParLambdaNat.happyReduce_16
  ParLambdaNat.happyReduce_17
  ParLambdaNat.happyReduce_18
  ParLambdaNat.happyReduce_19
  ParLambdaNat.happyReduce_20
  ParLambdaNat.happyReduce_21
  ParLambdaNat.happyReduce_22
  ParLambdaNat.happyReduce_23
  ParLambdaNat.happyReduce_24
  ParLambdaNat.happyReduce_7
  ParLambdaNat.happyReduce_8
  ParLambdaNat.happyReduce_9
  ParLambdaNat.happyReduction_10
  ParLambdaNat.happyReduction_11
  ParLambdaNat.happyReduction_12
  ParLambdaNat.happyReduction_13
  ParLambdaNat.happyReduction_14
  ParLambdaNat.happyReduction_15
  ParLambdaNat.happyReduction_16
  ParLambdaNat.happyReduction_17
  ParLambdaNat.happyReduction_18
  ParLambdaNat.happyReduction_19
  ParLambdaNat.happyReduction_20
  ParLambdaNat.happyReduction_21
  ParLambdaNat.happyReduction_22
  ParLambdaNat.happyReduction_23
  ParLambdaNat.happyReduction_24
  ParLambdaNat.happyReduction_7
  ParLambdaNat.happyReduction_8
  ParLambdaNat.happyReduction_9
  ParLambdaNat.happyReturn
  ParLambdaNat.happyReturn1
  ParLambdaNat.happySeq
  ParLambdaNat.happyShift
  ParLambdaNat.happySpecReduce_0
  ParLambdaNat.happySpecReduce_1
  ParLambdaNat.happySpecReduce_2
  ParLambdaNat.happySpecReduce_3
  ParLambdaNat.happyTable
  ParLambdaNat.happyTcHack
  ParLambdaNat.happyThen
  ParLambdaNat.happyThen1
  ParLambdaNat.happy_n_nonterms
  ParLambdaNat.happy_n_terms
  ParLambdaNat.indexShortOffAddr
  ParLambdaNat.myLexer
  ParLambdaNat.notHappyAtAll
  ParLambdaNat.pExp
  ParLambdaNat.pExp1
  ParLambdaNat.pExp2
  ParLambdaNat.pExp3
  ParLambdaNat.pExp4
  ParLambdaNat.pExp5
  ParLambdaNat.pProgram
  ParLambdaNat.readArrayBit
  ParLambdaNat.returnM
  ParLambdaNat.thenM
  ParLambdaNat.HappyAbsSyn{ParLambdaNat.HappyAbsSyn}
  ParLambdaNat.HappyAddr{ParLambdaNat.HappyA#}
  ParLambdaNat.HappyAny
  ParLambdaNat.HappyStk{ParLambdaNat.HappyStk}
  ParLambdaNat.Happy_IntList{ParLambdaNat.HappyCons}
module dependencies: AbsLambdaNat ErrM LexLambdaNat
package dependencies: array-0.5.3.0 base-4.12.0.0 ghc-prim-0.5.3
                      integer-gmp-1.0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity base-4.12.0.0:Data.Monoid
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:GHC.Exts base-4.12.0.0:GHC.Generics
                         base-4.12.0.0:GHC.IO.Exception
import  -/  AbsLambdaNat 745236951d5c61052b73076fb3499116
  exports: 6bc0e0a30e9a146968fbe55468d9d934
  EAbs 0a69fbb16f019191d50dcedb161ded32
  EApp 32415cea8f1fbfd2af05cf4800acecff
  EFix 6395ea9907b8f3cd011e5358e24b1ff2
  EIf 2c44990e8ebef8157136040becf70085
  ELet 26d9b983de91c6e91a4b02150e5aea1f
  EMinusOne 6882f9bd5e4b21c9aeb156812ef275e6
  ENat0 f524c7c2997600a81a704bf93ae14fa8
  ENatS 0beabf86dce5029feaba2530956df257
  ERec e1ba0373cab3adf252e1cc49d433c19e
  EVar 7f94047a8dc962e61fe85833c17f9a89
  Exp 59de0b5c3751d3cc05ebdfff5f7dffea
  Id 3ce23624695e9db53ed4602027be97b9
  Id 37ec743cab0dab77ff6e9884f6f093e6
  Prog 4c477988550b3d376e7280234cb1d42d
  Program 29c9775e149242b7aab51c8c0dd6ad45
import  -/  ErrM 891511a0d247a63f97006997da116fd7
  exports: 6a1a683d2b1212de37fcd511d370fe9e
  Bad 613b66b0140c47ad4a8db9688aa528ca
  Err ad25ec2d2de5d10f1e5da8cacfc24ac4
import  -/  LexLambdaNat 4317807d68d2fb3fa4b9203288eeabda
  exports: 668f4b03efc9e1563a3bba8b3d9b445c
  Err d891d82807a80958e95c967356758a34
  PT e68f17e0358a0e12199e41bcb2096f16
  TS 506cac93cda6fa864859a7211432f7fe
  T_Id 44df68f179af2d168fc1d5c4318e1379
  Token 887b41e9c96c891366c8c9b7a153cfd3
  prToken 71b11e68a2859e0afcf57d1eb5e5347f
  tokenPos 7841e9500951b431a5e125a7fbac5944
  tokens 6b3f4b523935b0e3f3be6f0a195efdbb
import  -/  array-0.5.3.0:Data.Array 92f4b3399a96adb44649ce9a9d6cd419
import  -/  base-4.12.0.0:Control.Applicative 2ae514eb141d45774730765c61bb41c0
import  -/  base-4.12.0.0:Control.Monad 07eaec7fd256019b318d048d00f45b1c
import  -/  base-4.12.0.0:Data.Bits 64fdef6c05b11e33e007318d457467e9
import  -/  base-4.12.0.0:Data.Foldable efb37371da929e7bc88d896298d2d979
import  -/  base-4.12.0.0:GHC.Arr ec26aa94fff9ed31a6fa85d884b35f3c
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Err ea5e313ef4146b40b5d8b27aa168e736
import  -/  base-4.12.0.0:GHC.Exts 5176e66011d4902498d2e6a4020ba73d
import  -/  base-4.12.0.0:GHC.List 4014a3c8a3b7c31c8325f6bcf1feea4a
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:GHC.Real af2b985dd29515c375fb78b2c9298d42
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
addDependentFile "/Users/alexanderkurz/.stack/programs/x86_64-osx/ghc-8.6.4/lib/ghc-8.6.4/include/ghcversion.h" a0ce8aeb7f525f4d70decd6c1d3ca2dd
addDependentFile ".stack-work/dist/x86_64-osx/Cabal-2.4.0.1/build/autogen/cabal_macros.h" ae3a7c442b1d2cc19b91d5dc56c66c54
fixities infixr 9 HappyStk, infixr 9 HappyStk
0a67e3c7f0ed1ea54e817b2b4118f677
  $tc'HappyA# :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11176824687290970358##
                   12843203370288234880##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tc'HappyA#2
                   0#
                   ParLambdaNat.$tc'HappyA#1) -}
4b4c7785650c1cd3e9960e2961363b48
  $tc'HappyA#1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a99b43ec875db5838f149c118398b9b0
  $tc'HappyA#2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tc'HappyA#3) -}
e14f09925d6bcd714527d7f9aa33f310
  $tc'HappyA#3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'HappyA#"#) -}
60d96aa39a086a46e52b1fd35287fe93
  $tc'HappyCons :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8798176905297002297##
                   1841235117625212422##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tc'HappyCons2
                   0#
                   ParLambdaNat.$tc'HappyCons1) -}
17a6ac07d1e49b46a2e33c95ec8a3677
  $tc'HappyCons1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5376a71ba7478d80c392651bceed6084
  $tc'HappyCons2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tc'HappyCons3) -}
a645a4db61539d177b77fa4cfcfc3b4a
  $tc'HappyCons3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'HappyCons"#) -}
dd640d90b564dc08ebab59ceafc61132
  $tc'HappyStk :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8648156413105868187##
                   8949683092317845728##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tc'HappyStk2
                   1#
                   ParLambdaNat.$tc'HappyStk1) -}
80cb7703de42d3b2797d60f94685cf44
  $tc'HappyStk1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
0d501ba023d9100370f28f7b8a3afcec
  $tc'HappyStk2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tc'HappyStk3) -}
1646e0b9103fd3b36deea87c80a7fe69
  $tc'HappyStk3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'HappyStk"#) -}
cd22809ade77bdaaf765ca490c3ecbeb
  $tcHappyAbsSyn :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17914897369945197902##
                   3753609758698298519##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tcHappyAbsSyn1
                   0#
                   GHC.Types.krep$*) -}
2580087d03fdebc2115666aa7b9f6c1a
  $tcHappyAbsSyn1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tcHappyAbsSyn2) -}
24cd4681b31585b4e8bca26398cdec81
  $tcHappyAbsSyn2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HappyAbsSyn"#) -}
96e7442f0ec737c2d9d9cad783960a2f
  $tcHappyAddr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2624366261470383115##
                   5546434622797744098##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tcHappyAddr1
                   0#
                   GHC.Types.krep$*) -}
42b37978f8347d17b65b91737faca356
  $tcHappyAddr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tcHappyAddr2) -}
051b0e271bbadde29123b3c2494bf4e2
  $tcHappyAddr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HappyAddr"#) -}
bee4925c40c85144ce549c1e38e8bb92
  $tcHappyStk :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16744984142758988557##
                   17662450783069897724##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tcHappyStk1
                   0#
                   GHC.Types.krep$*Arr*) -}
eeee18e9a1a5b4a3eda1ae58e54701be
  $tcHappyStk1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tcHappyStk2) -}
2ea67335b58f26deb7c48ef903748104
  $tcHappyStk2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HappyStk"#) -}
837e2f429289fffc5bb886ca8e47fbbd
  $tcHappy_IntList :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7275166663206710713##
                   15292100447495341493##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tcHappy_IntList1
                   0#
                   GHC.Types.krep$*) -}
0458d15920ae947d02f8cd9bba962efe
  $tcHappy_IntList1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tcHappy_IntList2) -}
49a142cd0a1e93a614608dc3aed0d4f4
  $tcHappy_IntList2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Happy_IntList"#) -}
ab2a1fcf307001a0936e04d79d74ad62
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   ParLambdaNat.$trModule3
                   ParLambdaNat.$trModule1) -}
5ea63ea1594ade64f8696b1fa0314459
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$trModule2) -}
0accd84118046f40d2d597957eb8d481
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ParLambdaNat"#) -}
3c2547f29b51173da7013fc8bc07024e
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$trModule4) -}
cf12f06876d926f48a2ce8bb6436525e
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("LambdaNat-0.1.0.0-4B7roTwwXlI2zWJKCli09t"#) -}
bc30fd54f48dfd7801bd48ee5491e6ce
  $whappyError :: [LexLambdaNat.Token] -> (# GHC.Base.String #)
  {- Arity: 1, Strictness: <L,U>, Inline: [2],
     Unfolding: (\ @ a (w :: [LexLambdaNat.Token]) ->
                 (# GHC.CString.unpackAppendCString#
                      ParLambdaNat.happyError6
                      (let {
                         n :: [GHC.Types.Char]
                         = case w of wild {
                             [] -> GHC.Types.[] @ GHC.Types.Char
                             : ds ds1
                             -> case ds of wild1 {
                                  LexLambdaNat.PT ipv ipv1
                                  -> GHC.CString.unpackAppendCString#
                                       ParLambdaNat.happyError5
                                       (case ipv1 of wild2 {
                                          LexLambdaNat.TS s dt
                                          -> GHC.Base.++ @ GHC.Types.Char s ParLambdaNat.happyError3
                                          LexLambdaNat.TL s
                                          -> GHC.Base.++_$s++
                                               @ GHC.Types.Char
                                               ParLambdaNat.happyError3
                                               GHC.Show.$fShow(,)3
                                               (GHC.Show.showLitString s GHC.Show.$fShow[]1)
                                          LexLambdaNat.TI s
                                          -> GHC.Base.++ @ GHC.Types.Char s ParLambdaNat.happyError3
                                          LexLambdaNat.TV s
                                          -> GHC.Base.++ @ GHC.Types.Char s ParLambdaNat.happyError3
                                          LexLambdaNat.TD s
                                          -> GHC.Base.++ @ GHC.Types.Char s ParLambdaNat.happyError3
                                          LexLambdaNat.TC s
                                          -> GHC.Base.++ @ GHC.Types.Char s ParLambdaNat.happyError3
                                          LexLambdaNat.T_Id s
                                          -> GHC.Base.++
                                               @ GHC.Types.Char
                                               s
                                               ParLambdaNat.happyError3 })
                                  LexLambdaNat.Err ds2
                                  -> case ds1 of wild2 {
                                       [] -> ParLambdaNat.happyError1
                                       : ipv ipv1
                                       -> GHC.CString.unpackAppendCString#
                                            ParLambdaNat.happyError5
                                            (GHC.Base.++
                                               @ GHC.Types.Char
                                               LexLambdaNat.prToken1
                                               ParLambdaNat.happyError3) } } }
                       } in
                       case w of wild {
                         [] -> GHC.Base.++ @ GHC.Types.Char LexLambdaNat.tokenPos1 n
                         : t ds1
                         -> case t of wild1 {
                              LexLambdaNat.PT p ds2
                              -> case p of ww { LexLambdaNat.Pn ww1 ww2 ww3 ->
                                 GHC.Base.++ @ GHC.Types.Char (LexLambdaNat.$wprintPosn ww2 ww3) n }
                              LexLambdaNat.Err p
                              -> case p of ww { LexLambdaNat.Pn ww1 ww2 ww3 ->
                                 GHC.Base.++
                                   @ GHC.Types.Char
                                   (LexLambdaNat.$wprintPosn ww2 ww3)
                                   n } } }) #)) -}
9bff73bb56465f95017abd45e63ba07c
  $whappyExpListPerState :: GHC.Prim.Int# -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,U>, Inline: -}
3c32ba60888bf88951525e056c4e6778
  $whappyFail ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,U><L,U><L,U(U,U)>,
     Inline: [2],
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w of ds {
                   DEFAULT
                   -> ParLambdaNat.happyDoAction_happyDoAction
                        0#
                        w1
                        w2
                        w3
                        (ParLambdaNat.HappyStk
                           @ ParLambdaNat.HappyAbsSyn
                           (GHC.Types.I# ds)
                             `cast`
                           (UnsafeCo representational GHC.Types.Int ParLambdaNat.HappyAbsSyn)
                           w4)
                   0#
                   -> case w4 of wild { ParLambdaNat.HappyStk x ds1 ->
                      case x `cast`
                           (UnsafeCo representational ParLambdaNat.HappyAbsSyn GHC.Types.Int) of wild1 { GHC.Types.I# i ->
                      \ (tks :: [LexLambdaNat.Token]) ->
                      case i of ds2 {
                        DEFAULT
                        -> case ParLambdaNat.$whappyError
                                  @ ParLambdaNat.HappyAbsSyn
                                  (GHC.Types.: @ LexLambdaNat.Token w1 tks) of ww { Unit# ww1 ->
                           ErrM.Bad @ ParLambdaNat.HappyAbsSyn ww1 }
                        17#
                        -> ParLambdaNat.happyError
                             @ ParLambdaNat.HappyAbsSyn
                             tks } } } }) -}
039b01bad5906596b9ae229d68d81ea8
  $whappyReduce ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <L,U><L,U><L,1*C1(U(U,U))><S,1*U><L,U><L,U><L,U(U,U)>,
     Inline: [2],
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: GHC.Prim.Int#)
                   (w2 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn)
                   (w3 :: GHC.Prim.Int#)
                   (w4 :: LexLambdaNat.Token)
                   (w5 :: ParLambdaNat.Happy_IntList)
                   (w6 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w3 of ds {
                   DEFAULT
                   -> case ParLambdaNat.happyDrop
                             (GHC.Prim.-# w 1#)
                             w5 of wild { ParLambdaNat.HappyCons st1 ds1 ->
                      case w2 w6 of a { ParLambdaNat.HappyStk ipv ipv1 ->
                      case ParLambdaNat.happyGotoOffsets of wild1 { ParLambdaNat.HappyA# arr ->
                      let {
                        off' :: GHC.Prim.Int# = GHC.Prim.*# st1 2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr off' of wild2 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr
                             (GHC.Prim.+# off' 1#) of wild3 { DEFAULT ->
                      case ParLambdaNat.happyTable of wild4 { ParLambdaNat.HappyA# arr1 ->
                      let {
                        off'1 :: GHC.Prim.Int#
                        = GHC.Prim.*#
                            (GHC.Prim.+#
                               (GHC.Prim.narrow16Int#
                                  (GHC.Prim.word2Int#
                                     (GHC.Prim.or#
                                        (GHC.Prim.uncheckedShiftL#
                                           (GHC.Prim.int2Word# (GHC.Prim.ord# wild3))
                                           8#)
                                        (GHC.Prim.int2Word# (GHC.Prim.ord# wild2)))))
                               w1)
                            2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr1 off'1 of wild5 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr1
                             (GHC.Prim.+# off'1 1#) of wild6 { DEFAULT ->
                      ParLambdaNat.happyDoAction_happyDoAction
                        ds
                        w4
                        (GHC.Prim.narrow16Int#
                           (GHC.Prim.word2Int#
                              (GHC.Prim.or#
                                 (GHC.Prim.uncheckedShiftL#
                                    (GHC.Prim.int2Word# (GHC.Prim.ord# wild6))
                                    8#)
                                 (GHC.Prim.int2Word# (GHC.Prim.ord# wild5)))))
                        wild
                        a } } } } } } } }
                   0#
                   -> case w6 of wild { ParLambdaNat.HappyStk x ds1 ->
                      case x `cast`
                           (UnsafeCo representational ParLambdaNat.HappyAbsSyn GHC.Types.Int) of wild1 { GHC.Types.I# i ->
                      \ (tks :: [LexLambdaNat.Token]) ->
                      case i of ds2 {
                        DEFAULT
                        -> case ParLambdaNat.$whappyError
                                  @ ParLambdaNat.HappyAbsSyn
                                  (GHC.Types.: @ LexLambdaNat.Token w4 tks) of ww { Unit# ww1 ->
                           ErrM.Bad @ ParLambdaNat.HappyAbsSyn ww1 }
                        17#
                        -> ParLambdaNat.happyError
                             @ ParLambdaNat.HappyAbsSyn
                             tks } } } }) -}
6a55ef0b73d593b2301563a6f2302816
  $whappySpecReduce_1 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <L,U><L,1*C1(U)><S,1*U><L,U><L,1*U(U,U)><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: LexLambdaNat.Token)
                   (w4 :: ParLambdaNat.Happy_IntList)
                   (ww :: ParLambdaNat.HappyAbsSyn)
                   (ww1 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w2 of ds {
                   DEFAULT
                   -> case w4 of wild { ParLambdaNat.HappyCons st ds1 ->
                      case ParLambdaNat.happyGotoOffsets of wild1 { ParLambdaNat.HappyA# arr ->
                      let {
                        off' :: GHC.Prim.Int# = GHC.Prim.*# st 2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr off' of wild2 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr
                             (GHC.Prim.+# off' 1#) of wild3 { DEFAULT ->
                      case ParLambdaNat.happyTable of wild4 { ParLambdaNat.HappyA# arr1 ->
                      let {
                        off'1 :: GHC.Prim.Int#
                        = GHC.Prim.*#
                            (GHC.Prim.+#
                               (GHC.Prim.narrow16Int#
                                  (GHC.Prim.word2Int#
                                     (GHC.Prim.or#
                                        (GHC.Prim.uncheckedShiftL#
                                           (GHC.Prim.int2Word# (GHC.Prim.ord# wild3))
                                           8#)
                                        (GHC.Prim.int2Word# (GHC.Prim.ord# wild2)))))
                               w)
                            2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr1 off'1 of wild5 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr1
                             (GHC.Prim.+# off'1 1#) of wild6 { DEFAULT ->
                      ParLambdaNat.happyDoAction_happyDoAction
                        ds
                        w3
                        (GHC.Prim.narrow16Int#
                           (GHC.Prim.word2Int#
                              (GHC.Prim.or#
                                 (GHC.Prim.uncheckedShiftL#
                                    (GHC.Prim.int2Word# (GHC.Prim.ord# wild6))
                                    8#)
                                 (GHC.Prim.int2Word# (GHC.Prim.ord# wild5)))))
                        wild
                        (ParLambdaNat.HappyStk
                           @ ParLambdaNat.HappyAbsSyn
                           (w1 ww)
                           ww1) } } } } } } }
                   0#
                   -> case ww
                             `cast`
                           (UnsafeCo representational ParLambdaNat.HappyAbsSyn GHC.Types.Int) of wild { GHC.Types.I# i ->
                      \ (tks :: [LexLambdaNat.Token]) ->
                      case i of ds1 {
                        DEFAULT
                        -> case ParLambdaNat.$whappyError
                                  @ ParLambdaNat.HappyAbsSyn
                                  (GHC.Types.: @ LexLambdaNat.Token w3 tks) of ww2 { Unit# ww3 ->
                           ErrM.Bad @ ParLambdaNat.HappyAbsSyn ww3 }
                        17#
                        -> ParLambdaNat.happyError @ ParLambdaNat.HappyAbsSyn tks } } }) -}
068cbe32174c2837e05ea073cc5b31b4
  $whappySpecReduce_2 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <L,U><L,1*C1(C1(U))><S,1*U><L,U><L,1*U(A,1*U(U,U))><L,U><L,1*U(U,U)>,
     Inline: [2],
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: LexLambdaNat.Token)
                   (w4 :: ParLambdaNat.Happy_IntList)
                   (ww :: ParLambdaNat.HappyAbsSyn)
                   (ww1 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w2 of ds {
                   DEFAULT
                   -> case w4 of wild { ParLambdaNat.HappyCons ds1 sts ->
                      case sts of wild1 { ParLambdaNat.HappyCons st ds2 ->
                      case ww1 of wild2 { ParLambdaNat.HappyStk v2 stk' ->
                      case ParLambdaNat.happyGotoOffsets of wild3 { ParLambdaNat.HappyA# arr ->
                      let {
                        off' :: GHC.Prim.Int# = GHC.Prim.*# st 2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr off' of wild4 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr
                             (GHC.Prim.+# off' 1#) of wild5 { DEFAULT ->
                      case ParLambdaNat.happyTable of wild6 { ParLambdaNat.HappyA# arr1 ->
                      let {
                        off'1 :: GHC.Prim.Int#
                        = GHC.Prim.*#
                            (GHC.Prim.+#
                               (GHC.Prim.narrow16Int#
                                  (GHC.Prim.word2Int#
                                     (GHC.Prim.or#
                                        (GHC.Prim.uncheckedShiftL#
                                           (GHC.Prim.int2Word# (GHC.Prim.ord# wild5))
                                           8#)
                                        (GHC.Prim.int2Word# (GHC.Prim.ord# wild4)))))
                               w)
                            2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr1 off'1 of wild7 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr1
                             (GHC.Prim.+# off'1 1#) of wild8 { DEFAULT ->
                      ParLambdaNat.happyDoAction_happyDoAction
                        ds
                        w3
                        (GHC.Prim.narrow16Int#
                           (GHC.Prim.word2Int#
                              (GHC.Prim.or#
                                 (GHC.Prim.uncheckedShiftL#
                                    (GHC.Prim.int2Word# (GHC.Prim.ord# wild8))
                                    8#)
                                 (GHC.Prim.int2Word# (GHC.Prim.ord# wild7)))))
                        wild1
                        (ParLambdaNat.HappyStk
                           @ ParLambdaNat.HappyAbsSyn
                           (w1 ww v2)
                           stk') } } } } } } } } }
                   0#
                   -> case ww
                             `cast`
                           (UnsafeCo representational ParLambdaNat.HappyAbsSyn GHC.Types.Int) of wild { GHC.Types.I# i ->
                      \ (tks :: [LexLambdaNat.Token]) ->
                      case i of ds1 {
                        DEFAULT
                        -> case ParLambdaNat.$whappyError
                                  @ ParLambdaNat.HappyAbsSyn
                                  (GHC.Types.: @ LexLambdaNat.Token w3 tks) of ww2 { Unit# ww3 ->
                           ErrM.Bad @ ParLambdaNat.HappyAbsSyn ww3 }
                        17#
                        -> ParLambdaNat.happyError @ ParLambdaNat.HappyAbsSyn tks } } }) -}
fd3d5fe00777b7b6c41a58bda6c97ff7
  $whappySpecReduce_3 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <L,U><L,1*C1(C1(C1(U)))><S,1*U><L,U><L,1*U(A,1*U(A,1*U(U,U)))><L,U><L,1*U(U,1*U(U,U))>,
     Inline: [2],
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: LexLambdaNat.Token)
                   (w4 :: ParLambdaNat.Happy_IntList)
                   (ww :: ParLambdaNat.HappyAbsSyn)
                   (ww1 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w2 of ds {
                   DEFAULT
                   -> case w4 of wild { ParLambdaNat.HappyCons ds1 ds2 ->
                      case ds2 of wild1 { ParLambdaNat.HappyCons ds3 sts ->
                      case sts of wild2 { ParLambdaNat.HappyCons st ds4 ->
                      case ww1 of wild3 { ParLambdaNat.HappyStk v2 ds5 ->
                      case ds5 of wild4 { ParLambdaNat.HappyStk v3 stk' ->
                      case ParLambdaNat.happyGotoOffsets of wild5 { ParLambdaNat.HappyA# arr ->
                      let {
                        off' :: GHC.Prim.Int# = GHC.Prim.*# st 2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr off' of wild6 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr
                             (GHC.Prim.+# off' 1#) of wild7 { DEFAULT ->
                      case ParLambdaNat.happyTable of wild8 { ParLambdaNat.HappyA# arr1 ->
                      let {
                        off'1 :: GHC.Prim.Int#
                        = GHC.Prim.*#
                            (GHC.Prim.+#
                               (GHC.Prim.narrow16Int#
                                  (GHC.Prim.word2Int#
                                     (GHC.Prim.or#
                                        (GHC.Prim.uncheckedShiftL#
                                           (GHC.Prim.int2Word# (GHC.Prim.ord# wild7))
                                           8#)
                                        (GHC.Prim.int2Word# (GHC.Prim.ord# wild6)))))
                               w)
                            2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr1 off'1 of wild9 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr1
                             (GHC.Prim.+# off'1 1#) of wild10 { DEFAULT ->
                      ParLambdaNat.happyDoAction_happyDoAction
                        ds
                        w3
                        (GHC.Prim.narrow16Int#
                           (GHC.Prim.word2Int#
                              (GHC.Prim.or#
                                 (GHC.Prim.uncheckedShiftL#
                                    (GHC.Prim.int2Word# (GHC.Prim.ord# wild10))
                                    8#)
                                 (GHC.Prim.int2Word# (GHC.Prim.ord# wild9)))))
                        wild2
                        (ParLambdaNat.HappyStk
                           @ ParLambdaNat.HappyAbsSyn
                           (w1 ww v2 v3)
                           stk') } } } } } } } } } } }
                   0#
                   -> case ww
                             `cast`
                           (UnsafeCo representational ParLambdaNat.HappyAbsSyn GHC.Types.Int) of wild { GHC.Types.I# i ->
                      \ (tks :: [LexLambdaNat.Token]) ->
                      case i of ds1 {
                        DEFAULT
                        -> case ParLambdaNat.$whappyError
                                  @ ParLambdaNat.HappyAbsSyn
                                  (GHC.Types.: @ LexLambdaNat.Token w3 tks) of ww2 { Unit# ww3 ->
                           ErrM.Bad @ ParLambdaNat.HappyAbsSyn ww3 }
                        17#
                        -> ParLambdaNat.happyError @ ParLambdaNat.HappyAbsSyn tks } } }) -}
a96fca4d5a02bd0260e7405dec941515
  newtype HappyAbsSyn = HappyAbsSyn ParLambdaNat.HappyAny
d1d2052324744060e5d4581e42306938
  data HappyAddr = HappyA# GHC.Prim.Addr#
4b4bee95aa6fce1fef0ded3cedaefefc
  type HappyAny = GHC.Types.Any
dedf03cda922e3eeca01cb828be6518a
  data HappyStk a = HappyStk a (ParLambdaNat.HappyStk a)
3b119a6b4c03ee7a8d28b9ce836724d6
  data Happy_IntList
    = HappyCons GHC.Prim.Int# ParLambdaNat.Happy_IntList
720838434ae5ae73489a6e3c82e01cf5
  happyAccept ::
    GHC.Prim.Int#
    -> p1
    -> GHC.Prim.Int#
    -> p2
    -> ParLambdaNat.HappyStk a
    -> b
    -> ErrM.Err a
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,A><L,A><L,A><S,1*U(U,1*U(U,A))><L,A>m1,
     Unfolding: InlineRule (6, True, False)
                (\ @ p
                   @ p1
                   @ a
                   @ b
                   (ds :: GHC.Prim.Int#)
                   (tk :: p)
                   (st :: GHC.Prim.Int#)
                   (sts :: p1)
                   (ds1 :: ParLambdaNat.HappyStk a)
                   (eta :: b) ->
                 case ds of ds2 {
                   DEFAULT
                   -> case ds1 of wild { ParLambdaNat.HappyStk ans ds3 ->
                      ErrM.Ok @ a ans }
                   0#
                   -> case ds1 of wild { ParLambdaNat.HappyStk ds3 ds4 ->
                      case ds4 of wild1 { ParLambdaNat.HappyStk ans ds5 ->
                      ErrM.Ok @ a ans } } }) -}
6fd5de272914f75d65c49ba809063962
  happyActOffsets :: ParLambdaNat.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: -}
973247ad6eae7e43dc899ca54aab7d35
  happyAdjustOffset :: GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (off :: GHC.Prim.Int#) -> off) -}
009c5102aab7cb842eef1a463662dd59
  happyCheck :: ParLambdaNat.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: -}
c2465b2943f55213b0bfa842efd64302
  happyDefActions :: ParLambdaNat.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: -}
b566245166453423e7d93dcef3f7c6cf
  happyDoAction ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 3, Strictness: <S,U><L,U><S,U>, Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyDoAction_happyDoAction -}
cf92d1608bfaf824b5cc930481c0323f
  happyDoAction_happyDoAction ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 3, Strictness: <S,U><L,U><S,U> -}
62ba0080e48c87a7ed847a2fd949ea36
  happyDoSeq :: a -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (a1 :: a) (b1 :: b) ->
                 case a1 of a2 { DEFAULT -> b1 }) -}
38b07fd0815a9f80986d7ed4c7951f8e
  happyDontSeq :: a -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (a1 :: a) (b1 :: b) -> b1) -}
ea6d854d98409b39a1fd7bd5e8ef55d0
  happyDrop ::
    GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList -> ParLambdaNat.Happy_IntList
  {- Arity: 2, HasNoCafRefs -}
f27fa320ea39244633e59d6d2bd28260
  happyDropStk ::
    GHC.Prim.Int# -> ParLambdaNat.HappyStk a -> ParLambdaNat.HappyStk a
  {- Arity: 2, HasNoCafRefs -}
ba814bd7522b9e56272525615cda51d3
  happyError :: [LexLambdaNat.Token] -> ErrM.Err a
  {- Arity: 1, Strictness: <L,U>m2, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.$whappyError @ a w of ww { Unit# ww1 ->
                 ErrM.Bad @ a ww1 }) -}
0e32fb005976eb1de760f3b062547dfd
  happyError' ::
    ([LexLambdaNat.Token], [GHC.Base.String]) -> ErrM.Err a
  {- Arity: 1, Strictness: <S,1*U(U,A)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: ([LexLambdaNat.Token], [GHC.Base.String])) ->
                 case ds of wild { (,) tokens ds1 ->
                 ParLambdaNat.happyError @ a tokens }) -}
d489ca104bf9e953cee3b40c24bb6862
  happyError1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ParLambdaNat.happyError2) -}
5569ad943dee6f64142259e2f72c02ae
  happyError2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" due to lexer error"#) -}
eab9c0307e5e275662abcc0b34d2d9e1
  happyError3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ParLambdaNat.happyError4) -}
805f970c32364e1f62fa73c7a9a8f457
  happyError4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'"#) -}
360273be80c603f7c7d24a8a892e3445
  happyError5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" before `"#) -}
9e616870aed3ab4f19b6bbee92c28f92
  happyError6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("syntax error at "#) -}
3da1b634b1dfe61edb9f0c41375540a7
  happyError_ ::
    [GHC.Base.String]
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> [LexLambdaNat.Token]
    -> ErrM.Err a
  {- Arity: 4, Strictness: <L,A><S,1*U><L,U><L,U>m2,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (explist :: [GHC.Base.String])
                   (ds :: GHC.Prim.Int#)
                   (tk :: LexLambdaNat.Token)
                   (tks :: [LexLambdaNat.Token]) ->
                 case ds of ds1 {
                   DEFAULT
                   -> ParLambdaNat.happyError
                        @ a
                        (GHC.Types.: @ LexLambdaNat.Token tk tks)
                   17# -> ParLambdaNat.happyError @ a tks }) -}
2d8971d9d801859aabc2ba6ca7ce1ad2
  happyExpList :: ParLambdaNat.HappyAddr
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (ParLambdaNat.HappyA# ParLambdaNat.happyExpList1) -}
0ff382ba22cb1f2f2a2f6adc8e11b8dc
  happyExpList1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\NUL\NUL\\2106\SOH\NULH\\219\EOT\NUL e\DC3\NUL\\128\DC4@\NUL\NULR\NUL\SOH\NUL\b\NUL\EOT\NUL m\DC3\NUL\NUL\NUL@\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NULR\NUL\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\\2106\SOH\NUL\NUL\NUL\NUL\NUL \ENQ\DLE\NUL\NUL\NUL@\NUL\NUL\\2106\SOH\NULH\\219\EOT\NUL\NUL\NUL\DC4\NUL\\128\\180M\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL \ENQ\DLE\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\\128\NUL\NUL\NUL\NUL\NUL\DLE\NUL\NUL\b\NUL\NUL\NUL\NUL\NUL\NUL\NUL \NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\SOH\NUL\NUL\NUL\NUL\NUL\NUL\NULH\\219\EOT\NUL m\DC3\NUL\NUL\b\NUL\NUL\NUL\\2106\SOH\NUL\NUL \NUL\NUL m\DC3\NUL\NUL\NUL \NUL\NUL\NUL\NUL\NUL\NULH\\219\EOT\NUL\NUL\\128\NUL\NUL\\128\\180M\NUL\NUL\NUL\NUL\NUL\NULH\\219\EOT\NUL\NUL\DLE\NUL\NUL\\128\\180M\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL"#) -}
974da0a6fa868248b041621aaf582fa0
  happyExpListPerState :: GHC.Types.Int -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 ParLambdaNat.$whappyExpListPerState ww1 }) -}
0e4408ac07f90984cf431ff7cbcb287d
  happyFail ::
    [[GHC.Types.Char]]
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 6, Strictness: <L,A><S,1*U><L,U><S,U><L,U><L,U(U,U)>,
     Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyFail_happyFail -}
c566bf6e2cb724a7d74512c81fed07c2
  happyFail_happyFail ::
    [[GHC.Types.Char]]
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 6, Strictness: <L,A><S,1*U><L,U><S,U><L,U><L,U(U,U)>,
     Inline: [2],
     Unfolding: InlineRule (6, True, True)
                (\ (w :: [[GHC.Types.Char]])
                   (w1 :: GHC.Prim.Int#)
                   (w2 :: LexLambdaNat.Token)
                   (w3 :: GHC.Prim.Int#)
                   (w4 :: ParLambdaNat.Happy_IntList)
                   (w5 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 ParLambdaNat.$whappyFail w1 w2 w3 w4 w5) -}
08d4b73e528d7fc361828ddaeaa24e9e
  happyGoto ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 4, Strictness: <S,U><S,U><L,U><S,U>, Inline: -}
059e994ca01d47e885f1b2fae3927864
  happyGotoOffsets :: ParLambdaNat.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: -}
a1ede4fe1902615d1cd9b2e211d2da20
  happyIn10 :: AbsLambdaNat.Id -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Id) -> x)
                  `cast`
                (<AbsLambdaNat.Id>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Id ParLambdaNat.HappyAbsSyn) -}
21c00751f3d6617e0787af69162ee539
  happyIn11 :: AbsLambdaNat.Program -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Program) -> x)
                  `cast`
                (<AbsLambdaNat.Program>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Program ParLambdaNat.HappyAbsSyn) -}
fb81fee86e5bf2edef68e0dbd65baadd
  happyIn12 :: AbsLambdaNat.Exp -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Exp) -> x)
                  `cast`
                (<AbsLambdaNat.Exp>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
75008dafc7dc938bc2b1210576f92bc1
  happyIn13 :: AbsLambdaNat.Exp -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Exp) -> x)
                  `cast`
                (<AbsLambdaNat.Exp>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
4b3872f1a25622a2eee5f1b8b3454b4d
  happyIn14 :: AbsLambdaNat.Exp -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Exp) -> x)
                  `cast`
                (<AbsLambdaNat.Exp>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
07fd761ad90e4376280b6515170fb38f
  happyIn15 :: AbsLambdaNat.Exp -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Exp) -> x)
                  `cast`
                (<AbsLambdaNat.Exp>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
44300762b6ba2925df1f2e265921c8b2
  happyIn16 :: AbsLambdaNat.Exp -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Exp) -> x)
                  `cast`
                (<AbsLambdaNat.Exp>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
0c73e90913ca84735d962f9923efa12a
  happyIn17 :: AbsLambdaNat.Exp -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Exp) -> x)
                  `cast`
                (<AbsLambdaNat.Exp>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
7ab672e938ee11121f21b36e6e216020
  happyInTok :: LexLambdaNat.Token -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: LexLambdaNat.Token) -> x)
                  `cast`
                (<LexLambdaNat.Token>_R
                 ->_R UnsafeCo representational LexLambdaNat.Token ParLambdaNat.HappyAbsSyn) -}
82f4f103df5d3247bbe4c5161800a264
  happyLt :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: GHC.Prim.Int#) (y :: GHC.Prim.Int#) ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x y)) -}
ba9524f3d8821d7e3a900773b635e161
  happyMonad2Reduce ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
        -> LexLambdaNat.Token -> ErrM.Err ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 8,
     Strictness: <L,U><L,U><L,1*C1(C1(U))><S,1*U><L,U><L,U><L,U><L,U(U,U)>,
     Unfolding: (\ (k :: GHC.Prim.Int#)
                   (nt :: GHC.Prim.Int#)
                   (fn :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                          -> LexLambdaNat.Token -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                   (ds :: GHC.Prim.Int#)
                   (tk :: LexLambdaNat.Token)
                   (st :: GHC.Prim.Int#)
                   (sts :: ParLambdaNat.Happy_IntList)
                   (stk :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case ds of ds1 {
                   DEFAULT
                   -> case ParLambdaNat.happyDrop
                             k
                             (ParLambdaNat.HappyCons
                                st
                                sts) of wild { ParLambdaNat.HappyCons st1 ds2 ->
                      case ParLambdaNat.happyGotoOffsets of wild1 { ParLambdaNat.HappyA# arr ->
                      let {
                        off' :: GHC.Prim.Int# = GHC.Prim.*# st1 2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr off' of wild2 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr
                             (GHC.Prim.+# off' 1#) of wild3 { DEFAULT ->
                      case ParLambdaNat.happyTable of wild4 { ParLambdaNat.HappyA# arr1 ->
                      let {
                        off'1 :: GHC.Prim.Int#
                        = GHC.Prim.*#
                            (GHC.Prim.+#
                               (GHC.Prim.narrow16Int#
                                  (GHC.Prim.word2Int#
                                     (GHC.Prim.or#
                                        (GHC.Prim.uncheckedShiftL#
                                           (GHC.Prim.int2Word# (GHC.Prim.ord# wild3))
                                           8#)
                                        (GHC.Prim.int2Word# (GHC.Prim.ord# wild2)))))
                               nt)
                            2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr1 off'1 of wild5 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr1
                             (GHC.Prim.+# off'1 1#) of wild6 { DEFAULT ->
                      let {
                        new_state :: GHC.Prim.Int#
                        = GHC.Prim.narrow16Int#
                            (GHC.Prim.word2Int#
                               (GHC.Prim.or#
                                  (GHC.Prim.uncheckedShiftL#
                                     (GHC.Prim.int2Word# (GHC.Prim.ord# wild6))
                                     8#)
                                  (GHC.Prim.int2Word# (GHC.Prim.ord# wild5))))
                      } in
                      let {
                        drop_stk :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                        = ParLambdaNat.happyDropStk @ ParLambdaNat.HappyAbsSyn k stk
                      } in
                      let {
                        m :: ErrM.Err ParLambdaNat.HappyAbsSyn = fn stk tk
                      } in
                      \ (tks :: [LexLambdaNat.Token]) ->
                      case m of wild7 {
                        ErrM.Ok a1
                        -> ParLambdaNat.happyNewToken
                             new_state
                             wild
                             (ParLambdaNat.HappyStk @ ParLambdaNat.HappyAbsSyn a1 drop_stk)
                             tks
                        ErrM.Bad s -> wild7 } } } } } } } }
                   0#
                   -> ParLambdaNat.happyFail
                        (GHC.Types.[] @ [GHC.Types.Char])
                        0#
                        tk
                        st
                        sts
                        stk }) -}
ac66351218ff4d7fab1e371206eaffa0
  happyMonadReduce ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
        -> LexLambdaNat.Token -> ErrM.Err ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 8,
     Strictness: <L,U><L,U><L,1*C1(C1(U))><S,1*U><L,U><L,U><L,U><L,U(U,U)>,
     Inline: -}
12203e46127f6a3d4ff8b857e0c7ea52
  happyNewToken ::
    GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,1*U> -}
d4c2aae06d2fe37198e95cd4f76e5429
  happyOut10 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Id
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Id) -}
42c3b45e0020b7207ca47aa43c6f7093
  happyOut11 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Program
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Program) -}
f8c0016d75fbc74120149a7b572e97d8
  happyOut12 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp) -}
51a31e6b6814cc52c954e8b376f3b9c2
  happyOut13 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp) -}
3d1413ccc7d77017bc3c1b39cccf8138
  happyOut14 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp) -}
8aaefdbb8c3dba0c11759cc3fb1ce6b5
  happyOut15 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp) -}
e54b77cfd82e6923ce963ee1b4290c24
  happyOut16 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp) -}
e9ec06286df1e8519cefeaead76a5e97
  happyOut17 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp) -}
eb463cea19637f10b20c5d199a1b086b
  happyOutTok :: ParLambdaNat.HappyAbsSyn -> LexLambdaNat.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn LexLambdaNat.Token) -}
a1763c4e3c0655e176b8ae7ef7a7a44d
  happyParse ::
    GHC.Prim.Int#
    -> [LexLambdaNat.Token] -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 2, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (start_state :: GHC.Prim.Int#) ->
                 ParLambdaNat.happyNewToken
                   start_state
                   (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                   (ParLambdaNat.notHappyAtAll
                      @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))) -}
ad474fd394603af5cb6fb5afe8aa8893
  happyReduce ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 8,
     Strictness: <S,U><S,U><L,1*C1(U(U,U))><S,1*U><L,U><L,A><L,U><L,U(U,U)>,
     Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyReduce_happyReduce -}
390e5f8204ea76001a98b5388aed0368
  happyReduceArr ::
    GHC.Arr.Array
      GHC.Types.Int
      (GHC.Prim.Int#
       -> LexLambdaNat.Token
       -> GHC.Prim.Int#
       -> ParLambdaNat.Happy_IntList
       -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
       -> [LexLambdaNat.Token]
       -> ErrM.Err ParLambdaNat.HappyAbsSyn)
  {- Unfolding: (case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             GHC.Arr.Array
                               GHC.Types.Int
                               (GHC.Prim.Int#
                                -> LexLambdaNat.Token
                                -> GHC.Prim.Int#
                                -> ParLambdaNat.Happy_IntList
                                -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                                -> [LexLambdaNat.Token]
                                -> ErrM.Err ParLambdaNat.HappyAbsSyn) #)
                        ParLambdaNat.happyReduceArr1 of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
d9dc8f4c0588e8f0960624c1abc6ddd7
  happyReduceArr1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Arr.Array
            GHC.Types.Int
            (GHC.Prim.Int#
             -> LexLambdaNat.Token
             -> GHC.Prim.Int#
             -> ParLambdaNat.Happy_IntList
             -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
             -> [LexLambdaNat.Token]
             -> ErrM.Err ParLambdaNat.HappyAbsSyn) #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s1# :: GHC.Prim.State#
                             GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.Prim.newArray#
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        @ GHC.Prim.RealWorld
                        18#
                        (GHC.Arr.arrEleBottom
                           @ (GHC.Prim.Int#
                              -> LexLambdaNat.Token
                              -> GHC.Prim.Int#
                              -> ParLambdaNat.Happy_IntList
                              -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                              -> [LexLambdaNat.Token]
                              -> ErrM.Err ParLambdaNat.HappyAbsSyn))
                        s1# of ds1 { (#,#) ipv ipv1 ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        0#
                        ParLambdaNat.happyReduce_7
                        ipv of s2# { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        1#
                        ParLambdaNat.happyReduce_8
                        s2# of s2#1 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        2#
                        ParLambdaNat.happyReduce_9
                        s2#1 of s2#2 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        3#
                        ParLambdaNat.happyReduce_10
                        s2#2 of s2#3 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        4#
                        ParLambdaNat.happyReduce_11
                        s2#3 of s2#4 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        5#
                        ParLambdaNat.happyReduce_12
                        s2#4 of s2#5 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        6#
                        ParLambdaNat.happyReduce_13
                        s2#5 of s2#6 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        7#
                        ParLambdaNat.happyReduce_14
                        s2#6 of s2#7 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        8#
                        ParLambdaNat.happyReduce_15
                        s2#7 of s2#8 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        9#
                        ParLambdaNat.happyReduce_16
                        s2#8 of s2#9 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        10#
                        ParLambdaNat.happyReduce_17
                        s2#9 of s2#10 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        11#
                        ParLambdaNat.happyReduce_18
                        s2#10 of s2#11 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        12#
                        ParLambdaNat.happyReduce_19
                        s2#11 of s2#12 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        13#
                        ParLambdaNat.happyReduce_20
                        s2#12 of s2#13 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        14#
                        ParLambdaNat.happyReduce_21
                        s2#13 of s2#14 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        15#
                        ParLambdaNat.happyReduce_22
                        s2#14 of s2#15 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        16#
                        ParLambdaNat.happyReduce_23
                        s2#15 of s2#16 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        17#
                        ParLambdaNat.happyReduce_24
                        s2#16 of s2#17 { DEFAULT ->
                 case GHC.Prim.unsafeFreezeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        s2#17 of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2,
                    GHC.Arr.Array
                      @ GHC.Types.Int
                      @ (GHC.Prim.Int#
                         -> LexLambdaNat.Token
                         -> GHC.Prim.Int#
                         -> ParLambdaNat.Happy_IntList
                         -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                         -> [LexLambdaNat.Token]
                         -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                      ParLambdaNat.happyReduceArr3
                      ParLambdaNat.happyReduceArr2
                      18#
                      ipv3 #) } } } } } } } } } } } } } } } } } } } }) -}
0d1c4a9cc7058b4a3abb991d6aaeadea
  happyReduceArr2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 24#) -}
43d9dd51245b6cb4e3713bff36e9a1f9
  happyReduceArr3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 7#) -}
63630bcec4745da67c652e1efdfbd480
  happyReduce_1 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x) -}
50be055d72edffd747127503b3d04521
  happyReduce_10 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   2#
                   ParLambdaNat.happyReduce_1
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
aa8293843e02341e68a9041fa36634d8
  happyReduce_11 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,U><L,U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 ParLambdaNat.$whappyReduce
                   8#
                   3#
                   ParLambdaNat.happyReduction_11
                   w
                   w1
                   w3
                   w4) -}
cd6c31ecc404f45906746af831adf9ae
  happyReduce_12 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,U><L,U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 ParLambdaNat.$whappyReduce
                   6#
                   3#
                   ParLambdaNat.happyReduction_12
                   w
                   w1
                   w3
                   w4) -}
94b56cdfd3754651020d56518f9bacf7
  happyReduce_13 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,U><L,U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 ParLambdaNat.$whappyReduce
                   7#
                   3#
                   ParLambdaNat.happyReduction_13
                   w
                   w1
                   w3
                   w4) -}
432760a79d076bc5be8f7501a11ee003
  happyReduce_14 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,A><L,1*U(A,1*U(U,U))><S,1*U(U,1*U(U,U))>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_2
                   3#
                   (ParLambdaNat.happyReduce_6 @ ParLambdaNat.HappyAbsSyn)
                     `cast`
                   (<ParLambdaNat.HappyAbsSyn>_R
                    ->_R <ParLambdaNat.HappyAbsSyn>_R
                    ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
6594560133272cda3de03af9d15593c5
  happyReduce_15 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,A><L,1*U(A,1*U(U,U))><S,1*U(U,1*U(U,U))>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_2
                   3#
                   (ParLambdaNat.happyReduce_5 @ ParLambdaNat.HappyAbsSyn)
                     `cast`
                   (<ParLambdaNat.HappyAbsSyn>_R
                    ->_R <ParLambdaNat.HappyAbsSyn>_R
                    ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
003412a2d3ffadc7f71f1705d87cf332
  happyReduce_16 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   3#
                   ParLambdaNat.happyReduce_1
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
c4e2dc002491e605fd4da9edc78127c1
  happyReduce_17 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,A><L,1*U(A,1*U(U,U))><S,1*U(U,1*U(U,U))>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_2
                   4#
                   ParLambdaNat.happyReduce_4
                     `cast`
                   (<ParLambdaNat.HappyAbsSyn>_R
                    ->_R <ParLambdaNat.HappyAbsSyn>_R
                    ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
5095dda0f5c6fddc3100852ee7e7678c
  happyReduce_18 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   4#
                   ParLambdaNat.happyReduce_1
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
118777bec29d04b04507f40fdc73ed7f
  happyReduce_19 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   5#
                   (ParLambdaNat.happyReduce_3 @ ParLambdaNat.HappyAbsSyn)
                     `cast`
                   (<ParLambdaNat.HappyAbsSyn>_R
                    ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
12d92a0d300bd2473a3317f207ac5dd3
  happyReduce_2 :: ParLambdaNat.HappyAbsSyn -> p -> AbsLambdaNat.Exp
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m9,
     Unfolding: InlineRule (2, True, True)
                (\ @ p (happy_x_2 :: ParLambdaNat.HappyAbsSyn) (happy_x_1 :: p) ->
                 AbsLambdaNat.ENatS
                   happy_x_2
                     `cast`
                   (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)) -}
a49d24f0cb0624a05ae54fac789ca9eb
  happyReduce_20 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,A><L,1*U(A,1*U(U,U))><S,1*U(U,1*U(U,U))>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_2
                   5#
                   (ParLambdaNat.happyReduce_2 @ ParLambdaNat.HappyAbsSyn)
                     `cast`
                   (<ParLambdaNat.HappyAbsSyn>_R
                    ->_R <ParLambdaNat.HappyAbsSyn>_R
                    ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
43e4cbca12095d20e44d5af55e19f331
  happyReduce_21 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   5#
                   ParLambdaNat.happyReduce_1
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
5b5b372b96906aa7e4f2090f6a246744
  happyReduce_22 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   6#
                   AbsLambdaNat.EVar
                     `cast`
                   (UnsafeCo representational AbsLambdaNat.Id ParLambdaNat.HappyAbsSyn
                    ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
464f97d80334d0e7380ed7115ab36e04
  happyReduce_23 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,A><L,1*U(A,1*U(A,1*U(U,U)))><S,1*U(U,1*U(U,1*U(U,U)))>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_3
                   6#
                   (ParLambdaNat.happyReduction_23
                      @ ParLambdaNat.HappyAbsSyn
                      @ ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
b52ec564f60fdc33c674f633171d02da
  happyReduce_24 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   7#
                   ParLambdaNat.happyReduce_1
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
2bb832f922ef282bb7a2c1b9e9a971ef
  happyReduce_3 :: p -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ p (happy_x_1 :: p) -> AbsLambdaNat.ENat0) -}
187185eaf596d5750a3bac7e06c6c50f
  happyReduce_4 ::
    ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m7,
     Unfolding: InlineRule (2, True, True)
                (\ (happy_x_2 :: ParLambdaNat.HappyAbsSyn)
                   (happy_x_1 :: ParLambdaNat.HappyAbsSyn) ->
                 AbsLambdaNat.EApp
                   happy_x_1
                     `cast`
                   (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   happy_x_2
                     `cast`
                   (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)) -}
7bd9d7fb565667b61b45e65e742d0602
  happyReduce_5 :: ParLambdaNat.HappyAbsSyn -> p -> AbsLambdaNat.Exp
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m6,
     Unfolding: InlineRule (2, True, True)
                (\ @ p (happy_x_2 :: ParLambdaNat.HappyAbsSyn) (happy_x_1 :: p) ->
                 AbsLambdaNat.EMinusOne
                   happy_x_2
                     `cast`
                   (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)) -}
19ae6fcb480707833254ecaf8558eefe
  happyReduce_6 :: ParLambdaNat.HappyAbsSyn -> p -> AbsLambdaNat.Exp
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m5,
     Unfolding: InlineRule (2, True, True)
                (\ @ p (happy_x_2 :: ParLambdaNat.HappyAbsSyn) (happy_x_1 :: p) ->
                 AbsLambdaNat.EFix
                   happy_x_2
                     `cast`
                   (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)) -}
5688cf2bf2a9d0d82803c4b9af415f11
  happyReduce_7 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   0#
                   ParLambdaNat.happyReduction_7
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
dcad930bf8b2527f1e4ca02ab6b3e81f
  happyReduce_8 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   1#
                   AbsLambdaNat.Prog
                     `cast`
                   (UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn
                    ->_R UnsafeCo representational AbsLambdaNat.Program ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
f365594bce80e17fe71da06899d615f3
  happyReduce_9 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,U><L,U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 ParLambdaNat.$whappyReduce
                   4#
                   2#
                   ParLambdaNat.happyReduction_9
                   w
                   w1
                   w3
                   w4) -}
707127d1249161b1709562f25486f557
  happyReduce_happyReduce ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 8,
     Strictness: <S,U><S,U><L,1*C1(U(U,U))><S,1*U><L,U><L,A><L,U><L,U(U,U)>,
     Inline: [2],
     Unfolding: InlineRule (8, True, True)
                (\ (w :: GHC.Prim.Int#)
                   (w1 :: GHC.Prim.Int#)
                   (w2 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn)
                   (w3 :: GHC.Prim.Int#)
                   (w4 :: LexLambdaNat.Token)
                   (w5 :: GHC.Prim.Int#)
                   (w6 :: ParLambdaNat.Happy_IntList)
                   (w7 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 ParLambdaNat.$whappyReduce w w1 w2 w3 w4 w6 w7) -}
4eb4c3a9250a7d06719d61b09ba57245
  happyReduction_1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("src/ParLambdaNat.hs:(141,13)-(144,10)|case"#) -}
0734717713332c9d859f2cdac98d0164
  happyReduction_10 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (happy_x_1 :: ParLambdaNat.HappyAbsSyn) -> happy_x_1) -}
5300ecf9ef25b2927d94b7b475bb2e92
  happyReduction_11 ::
    ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LS(LS(LS(LS(LS(LS))))))),1*U(U,1*U(A,1*U(U,1*U(A,1*U(U,1*U(A,1*U(U,1*U(A,U))))))))>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 case ww2 of ww3 { ParLambdaNat.HappyStk ww4 ww5 ->
                 case ww5 of ww6 { ParLambdaNat.HappyStk ww7 ww8 ->
                 case ww8 of ww9 { ParLambdaNat.HappyStk ww10 ww11 ->
                 case ww11 of ww12 { ParLambdaNat.HappyStk ww13 ww14 ->
                 case ww14 of ww15 { ParLambdaNat.HappyStk ww16 ww17 ->
                 case ww17 of ww18 { ParLambdaNat.HappyStk ww19 ww20 ->
                 case ww20 of ww21 { ParLambdaNat.HappyStk ww22 ww23 ->
                 ParLambdaNat.HappyStk
                   @ ParLambdaNat.HappyAbsSyn
                   (AbsLambdaNat.EIf
                      ww19
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                      ww13
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                      ww7
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                      ww1
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp))
                     `cast`
                   (UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   ww23 } } } } } } } }) -}
0a2cfc666d4847a88c36ee48703b2376
  happyReduction_12 ::
    ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LS(LS(LS(LS))))),1*U(U,1*U(A,1*U(U,1*U(A,1*U(U,1*U(A,U))))))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case ds of wild { ParLambdaNat.HappyStk happy_x_6 ds1 ->
                 case ds1 of wild1 { ParLambdaNat.HappyStk happy_x_5 ds2 ->
                 case ds2 of wild2 { ParLambdaNat.HappyStk happy_x_4 ds3 ->
                 case ds3 of wild3 { ParLambdaNat.HappyStk happy_x_3 ds4 ->
                 case ds4 of wild4 { ParLambdaNat.HappyStk happy_x_2 ds5 ->
                 case ds5 of wild5 { ParLambdaNat.HappyStk happy_x_1 happyRest ->
                 ParLambdaNat.HappyStk
                   @ ParLambdaNat.HappyAbsSyn
                   (AbsLambdaNat.ELet
                      happy_x_2
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Id)
                      happy_x_4
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                      happy_x_6
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp))
                     `cast`
                   (UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   happyRest } } } } } }) -}
de8e67cf25920312d91e06e2f4c8ed19
  happyReduction_13 ::
    ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LS(LS(LS(LS(LS)))))),1*U(U,1*U(A,1*U(U,1*U(A,1*U(U,1*U(A,1*U(A,U)))))))>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 case ww2 of ww3 { ParLambdaNat.HappyStk ww4 ww5 ->
                 case ww5 of ww6 { ParLambdaNat.HappyStk ww7 ww8 ->
                 case ww8 of ww9 { ParLambdaNat.HappyStk ww10 ww11 ->
                 case ww11 of ww12 { ParLambdaNat.HappyStk ww13 ww14 ->
                 case ww14 of ww15 { ParLambdaNat.HappyStk ww16 ww17 ->
                 case ww17 of ww18 { ParLambdaNat.HappyStk ww19 ww20 ->
                 ParLambdaNat.HappyStk
                   @ ParLambdaNat.HappyAbsSyn
                   (AbsLambdaNat.ERec
                      ww13
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Id)
                      ww7
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                      ww1
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp))
                     `cast`
                   (UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   ww20 } } } } } } }) -}
0324a573ea83bfd66e94a9be4f47daeb
  happyReduction_14 ::
    ParLambdaNat.HappyAbsSyn -> p -> ParLambdaNat.HappyAbsSyn
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m5,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyReduce_6
                  `cast`
                (forall (p :: <*>_N).
                 <ParLambdaNat.HappyAbsSyn>_R
                 ->_R <p>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
3879fc363fccbd06fe44bdae86ead3e8
  happyReduction_15 ::
    ParLambdaNat.HappyAbsSyn -> p -> ParLambdaNat.HappyAbsSyn
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m6,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyReduce_5
                  `cast`
                (forall (p :: <*>_N).
                 <ParLambdaNat.HappyAbsSyn>_R
                 ->_R <p>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
646bf63a877005b0d13a48f30d464d06
  happyReduction_16 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (happy_x_1 :: ParLambdaNat.HappyAbsSyn) -> happy_x_1) -}
f9e5752d913e6ea0b6b053fd998ed93b
  happyReduction_17 ::
    ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m7,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyReduce_4
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R <ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
ad586f2620c40c93945f0010753ce7aa
  happyReduction_18 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (happy_x_1 :: ParLambdaNat.HappyAbsSyn) -> happy_x_1) -}
d44f5ceff45024811ddad05d536942b3
  happyReduction_19 :: p -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyReduce_3
                  `cast`
                (forall (p :: <*>_N).
                 <p>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
95cd3f2f25d978b29886a5b3554d2942
  happyReduction_20 ::
    ParLambdaNat.HappyAbsSyn -> p -> ParLambdaNat.HappyAbsSyn
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m9,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyReduce_2
                  `cast`
                (forall (p :: <*>_N).
                 <ParLambdaNat.HappyAbsSyn>_R
                 ->_R <p>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
56de79b571f556d1b753cc9735e069b6
  happyReduction_21 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (happy_x_1 :: ParLambdaNat.HappyAbsSyn) -> happy_x_1) -}
d37d14c86d9d707450fb1178605763b2
  happyReduction_22 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m10,
     Unfolding: InlineRule (0, True, True)
                AbsLambdaNat.EVar
                  `cast`
                (UnsafeCo representational AbsLambdaNat.Id ParLambdaNat.HappyAbsSyn
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
61baa1602d399149e109ad5b3d5cc11d
  happyReduction_23 ::
    p1 -> ParLambdaNat.HappyAbsSyn -> p2 -> ParLambdaNat.HappyAbsSyn
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   @ p1
                   (happy_x_3 :: p)
                   (happy_x_2 :: ParLambdaNat.HappyAbsSyn)
                   (happy_x_1 :: p1) ->
                 happy_x_2) -}
63844be93e31cd0f6063221041d1628b
  happyReduction_24 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (happy_x_1 :: ParLambdaNat.HappyAbsSyn) -> happy_x_1) -}
0be6c54928237e29a39461e9f2c414c0
  happyReduction_7 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (happy_x_1 :: ParLambdaNat.HappyAbsSyn) ->
                 case happy_x_1
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn LexLambdaNat.Token) of wild {
                   LexLambdaNat.PT ds ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ ParLambdaNat.HappyAbsSyn
                             ParLambdaNat.happyReduction_1
                        LexLambdaNat.T_Id happy_var_1
                        -> happy_var_1
                             `cast`
                           (Sym (AbsLambdaNat.N:Id[0]) ; UnsafeCo representational AbsLambdaNat.Id ParLambdaNat.HappyAbsSyn) }
                   LexLambdaNat.Err ipv
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ ParLambdaNat.HappyAbsSyn
                        ParLambdaNat.happyReduction_1 }) -}
c590cabe540c8ed9d79dbbb9513f9b57
  happyReduction_8 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (0, True, True)
                AbsLambdaNat.Prog
                  `cast`
                (UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn
                 ->_R UnsafeCo representational AbsLambdaNat.Program ParLambdaNat.HappyAbsSyn) -}
a396c318c8f2429b30c3e65f9ba200f5
  happyReduction_9 ::
    ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LS(LS))),1*U(U,1*U(A,1*U(U,1*U(A,U))))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case ds of wild { ParLambdaNat.HappyStk happy_x_4 ds1 ->
                 case ds1 of wild1 { ParLambdaNat.HappyStk happy_x_3 ds2 ->
                 case ds2 of wild2 { ParLambdaNat.HappyStk happy_x_2 ds3 ->
                 case ds3 of wild3 { ParLambdaNat.HappyStk happy_x_1 happyRest ->
                 ParLambdaNat.HappyStk
                   @ ParLambdaNat.HappyAbsSyn
                   (AbsLambdaNat.EAbs
                      happy_x_2
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Id)
                      happy_x_4
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp))
                     `cast`
                   (UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   happyRest } } } }) -}
94fe962a48c8678a271e1e748890937b
  happyReturn :: a -> ErrM.Err a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m1,
     Unfolding: InlineRule (0, True, True) ErrM.Ok -}
73375d56772e2262b8b3e4cd5d9194f7
  happyReturn1 :: a -> b -> ErrM.Err a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m1,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (a1 :: a) (tks :: b) -> ErrM.Ok @ a a1) -}
507a5bbce72bc39b4e4c672d22b43974
  happySeq :: a -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (0, True, True) ParLambdaNat.happyDontSeq -}
f0f382cc31c6db712425e154de868eb4
  happyShift ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 6, Strictness: <S,U><S,1*U><L,U><L,U><L,U><L,U(U,U)>,
     Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyShift_happyShift -}
fbea57751748afc4e1b932633001b361
  happyShift_happyShift ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 6, Strictness: <S,U><S,1*U><L,U><L,U><L,U><L,U(U,U)>,
     Unfolding: (\ (new_state :: GHC.Prim.Int#)
                   (ds :: GHC.Prim.Int#)
                   (tk :: LexLambdaNat.Token)
                   (st :: GHC.Prim.Int#)
                   (sts :: ParLambdaNat.Happy_IntList)
                   (stk :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case ds of ds1 {
                   DEFAULT
                   -> ParLambdaNat.happyNewToken
                        new_state
                        (ParLambdaNat.HappyCons st sts)
                        (ParLambdaNat.HappyStk
                           @ ParLambdaNat.HappyAbsSyn
                           tk
                             `cast`
                           (UnsafeCo representational LexLambdaNat.Token ParLambdaNat.HappyAbsSyn)
                           stk)
                   0#
                   -> case stk of wild { ParLambdaNat.HappyStk x ds2 ->
                      case x `cast`
                           (UnsafeCo representational ParLambdaNat.HappyAbsSyn GHC.Types.Int) of wild1 { GHC.Types.I# i ->
                      ParLambdaNat.happyDoAction_happyDoAction
                        i
                        tk
                        new_state
                        (ParLambdaNat.HappyCons st sts)
                        wild } } }) -}
a4bfdee4364321a415204e0a8ec426f4
  happySpecReduce_0 ::
    GHC.Prim.Int#
    -> ParLambdaNat.HappyAbsSyn
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <L,U><L,U><S,1*U><L,U><S,U><L,U><L,U(U,U)>, Inline: -}
179835b6368d71e3ea3f09c87c0549a1
  happySpecReduce_1 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <S,U><L,1*C1(U)><S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happySpecReduce_1_happySpecReduce_1 -}
d228cc0a231d9a0f92855d720544aabf
  happySpecReduce_1_happySpecReduce_1 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <S,U><L,1*C1(U)><S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Inline: [2],
     Unfolding: InlineRule (7, True, False)
                (\ (w :: GHC.Prim.Int#)
                   (w1 :: ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: LexLambdaNat.Token)
                   (w4 :: GHC.Prim.Int#)
                   (w5 :: ParLambdaNat.Happy_IntList)
                   (w6 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w6 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1 w w1 w2 w3 w5 ww1 ww2 }) -}
2069b17aae722ebdfb39b3e834273a65
  happySpecReduce_2 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <S,U><L,1*C1(C1(U))><S,1*U><L,U><L,A><L,1*U(A,1*U(U,U))><S,1*U(U,1*U(U,U))>,
     Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happySpecReduce_2_happySpecReduce_2 -}
6c11fdbdd4a93da2ed9a83bb958f7dca
  happySpecReduce_2_happySpecReduce_2 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <S,U><L,1*C1(C1(U))><S,1*U><L,U><L,A><L,1*U(A,1*U(U,U))><S,1*U(U,1*U(U,U))>,
     Inline: [2],
     Unfolding: InlineRule (7, True, False)
                (\ (w :: GHC.Prim.Int#)
                   (w1 :: ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: LexLambdaNat.Token)
                   (w4 :: GHC.Prim.Int#)
                   (w5 :: ParLambdaNat.Happy_IntList)
                   (w6 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w6 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_2 w w1 w2 w3 w5 ww1 ww2 }) -}
b92bec2cda7a9a77b3ad958845fad29f
  happySpecReduce_3 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <S,U><L,1*C1(C1(C1(U)))><S,1*U><L,U><L,A><L,1*U(A,1*U(A,1*U(U,U)))><S,1*U(U,1*U(U,1*U(U,U)))>,
     Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happySpecReduce_3_happySpecReduce_3 -}
850a292fc31e6b4d20ac4fce139a2156
  happySpecReduce_3_happySpecReduce_3 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <S,U><L,1*C1(C1(C1(U)))><S,1*U><L,U><L,A><L,1*U(A,1*U(A,1*U(U,U)))><S,1*U(U,1*U(U,1*U(U,U)))>,
     Inline: [2],
     Unfolding: InlineRule (7, True, False)
                (\ (w :: GHC.Prim.Int#)
                   (w1 :: ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: LexLambdaNat.Token)
                   (w4 :: GHC.Prim.Int#)
                   (w5 :: ParLambdaNat.Happy_IntList)
                   (w6 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w6 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_3 w w1 w2 w3 w5 ww1 ww2 }) -}
7dc2b14baa5dc79f1d0934af006658ad
  happyTable :: ParLambdaNat.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: -}
c086883d9ffbe6a7e13672c54593361d
  happyTcHack :: GHC.Prim.Int# -> a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, True)
                (\ @ a (x :: GHC.Prim.Int#) (y :: a) -> y) -}
21ae9e386bf1f223ceca725d6d3aee65
  happyThen :: ErrM.Err a -> (a -> ErrM.Err b) -> ErrM.Err b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True) ErrM.$fMonadErr_$c>>= -}
ff9eb101a00690eb54f8d8a2c5808935
  happyThen1 ::
    ErrM.Err t1 -> (t1 -> t2 -> ErrM.Err b) -> t2 -> ErrM.Err b
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(C1(U))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ t
                   @ t1
                   @ b
                   (m :: ErrM.Err t)
                   (k :: t -> t1 -> ErrM.Err b)
                   (tks :: t1) ->
                 case m of wild {
                   ErrM.Ok a1 -> k a1 tks ErrM.Bad s -> ErrM.Bad @ b s }) -}
39a8fb2dce041ee4a35ab3246c60abae
  happy_n_nonterms :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 8#) -}
34e92c213a75029c2220e2a020b7565d
  happy_n_terms :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 18#) -}
ef8298cbd575c3d2c6fbace3bb061991
  indexShortOffAddr ::
    ParLambdaNat.HappyAddr -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: ParLambdaNat.HappyAddr) (off :: GHC.Prim.Int#) ->
                 case ds of wild { ParLambdaNat.HappyA# arr ->
                 let {
                   off' :: GHC.Prim.Int# = GHC.Prim.*# off 2#
                 } in
                 case GHC.Prim.indexCharOffAddr# arr off' of wild1 { DEFAULT ->
                 case GHC.Prim.indexCharOffAddr#
                        arr
                        (GHC.Prim.+# off' 1#) of wild2 { DEFAULT ->
                 GHC.Prim.narrow16Int#
                   (GHC.Prim.word2Int#
                      (GHC.Prim.or#
                         (GHC.Prim.uncheckedShiftL#
                            (GHC.Prim.int2Word# (GHC.Prim.ord# wild2))
                            8#)
                         (GHC.Prim.int2Word# (GHC.Prim.ord# wild1)))) } } }) -}
afc3464d813c718b0bd97bcc7c505d5b
  myLexer :: GHC.Base.String -> [LexLambdaNat.Token]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True) LexLambdaNat.tokens -}
771ac3260840ba9ebaf05c5520770569
  notHappyAtAll :: a
  {- Strictness: x -}
fd4088bea156b847917e8ac42f39ed4f
  pExp :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Exp
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        6#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Exp
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Exp s }) -}
8a6342d83c1730aa53c977bceeba9947
  pExp1 :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Exp
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        1#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Exp
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Exp s }) -}
796083565d741cae14b8b7baf49e853e
  pExp2 :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Exp
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        2#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Exp
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Exp s }) -}
5b2742ab7a84d7b0c3d3683b69367de9
  pExp3 :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Exp
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        3#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Exp
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Exp s }) -}
6586c1e6f6dd64007f1351668eddfac9
  pExp4 :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Exp
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        4#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Exp
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Exp s }) -}
44856a296f4329c0072dd0b53e0becf6
  pExp5 :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Exp
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        5#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Exp
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Exp s }) -}
74395369b19836ab0ef4a910b71276c1
  pProgram :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Program
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        0#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Program
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Program)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Program s }) -}
dbd320b535bcfc2d9a99fa555419c90e
  readArrayBit ::
    ParLambdaNat.HappyAddr -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (arr :: ParLambdaNat.HappyAddr) (bit :: GHC.Types.Int) ->
                 case bit of wild { GHC.Types.I# x ->
                 case arr of wild1 { ParLambdaNat.HappyA# arr1 ->
                 let {
                   off' :: GHC.Prim.Int#
                   = GHC.Prim.*# (GHC.Prim.uncheckedIShiftRA# x 4#) 2#
                 } in
                 case GHC.Prim.indexCharOffAddr# arr1 off' of wild2 { DEFAULT ->
                 case GHC.Prim.indexCharOffAddr#
                        arr1
                        (GHC.Prim.+# off' 1#) of wild3 { DEFAULT ->
                 let {
                   i# :: GHC.Prim.Int# = GHC.Prim.andI# x 15#
                 } in
                 case GHC.Prim.>=# i# 64# of lwild {
                   DEFAULT
                   -> case GHC.Prim.andI#
                             (GHC.Prim.narrow16Int#
                                (GHC.Prim.word2Int#
                                   (GHC.Prim.or#
                                      (GHC.Prim.uncheckedShiftL#
                                         (GHC.Prim.int2Word# (GHC.Prim.ord# wild3))
                                         8#)
                                      (GHC.Prim.int2Word# (GHC.Prim.ord# wild2)))))
                             (GHC.Prim.uncheckedIShiftL# 1# i#) of wild4 {
                        DEFAULT -> GHC.Types.True 0# -> GHC.Types.False }
                   1# -> GHC.Types.False } } } } }) -}
9292982dfea1736c4d4bdcf6df1e4c3e
  returnM :: a -> ErrM.Err a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m1,
     Unfolding: InlineRule (0, True, True) ErrM.Ok -}
b607324c183ad3a5dda52fc053d09361
  thenM :: ErrM.Err a -> (a -> ErrM.Err b) -> ErrM.Err b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True) ErrM.$fMonadErr_$c>>= -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

