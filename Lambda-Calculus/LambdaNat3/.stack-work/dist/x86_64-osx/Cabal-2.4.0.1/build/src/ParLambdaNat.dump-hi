
==================== FINAL INTERFACE ====================
2019-09-08 00:19:19.645744 UTC

interface LambdaNat-0.1.0.0-4B7roTwwXlI2zWJKCli09t:ParLambdaNat 8064
  interface hash: 7e3e1db72dc035d193985d5296efabc5
  ABI hash: f0e99800947333ce3285fbdc9e0e8e5d
  export-list hash: 9ac4268da28dab7d5a78016f074ed1bf
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 64b15dc763247db9f2b7005aec11540e
  opt_hash: 6faf2de08de32d19db9870899d88e59a
  hpc_hash: 93b885adfe0da089cdf634904fd59f71
  plugin_hash: ad164012d6b1e14942349d58b1132007
  sig of: Nothing
  used TH splices: False
  where
exports:
  ParLambdaNat.happyAccept
  ParLambdaNat.happyActOffsets
  ParLambdaNat.happyAdjustOffset
  ParLambdaNat.happyCheck
  ParLambdaNat.happyDefActions
  ParLambdaNat.happyDoAction
  ParLambdaNat.happyDoSeq
  ParLambdaNat.happyDontSeq
  ParLambdaNat.happyDrop
  ParLambdaNat.happyDropStk
  ParLambdaNat.happyError
  ParLambdaNat.happyError'
  ParLambdaNat.happyError_
  ParLambdaNat.happyExpList
  ParLambdaNat.happyExpListPerState
  ParLambdaNat.happyFail
  ParLambdaNat.happyGoto
  ParLambdaNat.happyGotoOffsets
  ParLambdaNat.happyIn10
  ParLambdaNat.happyIn11
  ParLambdaNat.happyIn12
  ParLambdaNat.happyIn13
  ParLambdaNat.happyIn14
  ParLambdaNat.happyIn15
  ParLambdaNat.happyIn16
  ParLambdaNat.happyIn17
  ParLambdaNat.happyInTok
  ParLambdaNat.happyLt
  ParLambdaNat.happyMonad2Reduce
  ParLambdaNat.happyMonadReduce
  ParLambdaNat.happyNewToken
  ParLambdaNat.happyOut10
  ParLambdaNat.happyOut11
  ParLambdaNat.happyOut12
  ParLambdaNat.happyOut13
  ParLambdaNat.happyOut14
  ParLambdaNat.happyOut15
  ParLambdaNat.happyOut16
  ParLambdaNat.happyOut17
  ParLambdaNat.happyOutTok
  ParLambdaNat.happyParse
  ParLambdaNat.happyReduce
  ParLambdaNat.happyReduceArr
  ParLambdaNat.happyReduce_10
  ParLambdaNat.happyReduce_11
  ParLambdaNat.happyReduce_12
  ParLambdaNat.happyReduce_13
  ParLambdaNat.happyReduce_14
  ParLambdaNat.happyReduce_15
  ParLambdaNat.happyReduce_16
  ParLambdaNat.happyReduce_17
  ParLambdaNat.happyReduce_18
  ParLambdaNat.happyReduce_19
  ParLambdaNat.happyReduce_20
  ParLambdaNat.happyReduce_7
  ParLambdaNat.happyReduce_8
  ParLambdaNat.happyReduce_9
  ParLambdaNat.happyReduction_10
  ParLambdaNat.happyReduction_11
  ParLambdaNat.happyReduction_12
  ParLambdaNat.happyReduction_13
  ParLambdaNat.happyReduction_14
  ParLambdaNat.happyReduction_15
  ParLambdaNat.happyReduction_16
  ParLambdaNat.happyReduction_17
  ParLambdaNat.happyReduction_18
  ParLambdaNat.happyReduction_19
  ParLambdaNat.happyReduction_20
  ParLambdaNat.happyReduction_7
  ParLambdaNat.happyReduction_8
  ParLambdaNat.happyReduction_9
  ParLambdaNat.happyReturn
  ParLambdaNat.happyReturn1
  ParLambdaNat.happySeq
  ParLambdaNat.happyShift
  ParLambdaNat.happySpecReduce_0
  ParLambdaNat.happySpecReduce_1
  ParLambdaNat.happySpecReduce_2
  ParLambdaNat.happySpecReduce_3
  ParLambdaNat.happyTable
  ParLambdaNat.happyTcHack
  ParLambdaNat.happyThen
  ParLambdaNat.happyThen1
  ParLambdaNat.happy_n_nonterms
  ParLambdaNat.happy_n_terms
  ParLambdaNat.indexShortOffAddr
  ParLambdaNat.myLexer
  ParLambdaNat.notHappyAtAll
  ParLambdaNat.pExp
  ParLambdaNat.pExp1
  ParLambdaNat.pExp2
  ParLambdaNat.pExp3
  ParLambdaNat.pExp4
  ParLambdaNat.pExp5
  ParLambdaNat.pProgram
  ParLambdaNat.readArrayBit
  ParLambdaNat.returnM
  ParLambdaNat.thenM
  ParLambdaNat.HappyAbsSyn{ParLambdaNat.HappyAbsSyn}
  ParLambdaNat.HappyAddr{ParLambdaNat.HappyA#}
  ParLambdaNat.HappyAny
  ParLambdaNat.HappyStk{ParLambdaNat.HappyStk}
  ParLambdaNat.Happy_IntList{ParLambdaNat.HappyCons}
module dependencies: AbsLambdaNat ErrM LexLambdaNat
package dependencies: array-0.5.3.0 base-4.12.0.0 ghc-prim-0.5.3
                      integer-gmp-1.0.2.0
orphans: base-4.12.0.0:GHC.Float base-4.12.0.0:GHC.Base
family instance modules: base-4.12.0.0:Control.Applicative
                         base-4.12.0.0:Data.Functor.Const
                         base-4.12.0.0:Data.Functor.Identity base-4.12.0.0:Data.Monoid
                         base-4.12.0.0:Data.Semigroup.Internal base-4.12.0.0:Data.Version
                         base-4.12.0.0:GHC.Exts base-4.12.0.0:GHC.Generics
                         base-4.12.0.0:GHC.IO.Exception
import  -/  AbsLambdaNat 32062a0e555d06f265c422e8923647b0
  exports: 4127fad46408b74fdf89ff0b87b4c806
  EAbs f2419bb11c4b97e3c40465d06de9c2e6
  EApp ac7e44963d74c424cc61cc9297408698
  EIf d8eb6af10b504683f0ea4e0a3a68ae85
  ENat0 28d2d5ef8548b75bb521cc7a591501dc
  ENatS 58633ac00b74a7732b16b7efa9592068
  EVar 2f1f50ba4820d8bbbfe4f9487753d569
  Exp 1b540221eceb6139b7214957e8ed98bd
  Id 3ce23624695e9db53ed4602027be97b9
  Id 37ec743cab0dab77ff6e9884f6f093e6
  Prog 76695b0bcd957f894fe4e8399e276cf4
  Program 81a6c22736a1c7d617742e2b38ff8d23
import  -/  ErrM 891511a0d247a63f97006997da116fd7
  exports: 6a1a683d2b1212de37fcd511d370fe9e
  Bad 613b66b0140c47ad4a8db9688aa528ca
  Err ad25ec2d2de5d10f1e5da8cacfc24ac4
import  -/  LexLambdaNat 9d1ef93f4167db8c6d4009b1a6b1a6d5
  exports: 668f4b03efc9e1563a3bba8b3d9b445c
  Err d891d82807a80958e95c967356758a34
  PT e68f17e0358a0e12199e41bcb2096f16
  TS 506cac93cda6fa864859a7211432f7fe
  T_Id 44df68f179af2d168fc1d5c4318e1379
  Token 887b41e9c96c891366c8c9b7a153cfd3
  prToken 71b11e68a2859e0afcf57d1eb5e5347f
  tokenPos 7841e9500951b431a5e125a7fbac5944
  tokens 6b3f4b523935b0e3f3be6f0a195efdbb
import  -/  array-0.5.3.0:Data.Array 92f4b3399a96adb44649ce9a9d6cd419
import  -/  base-4.12.0.0:Control.Applicative 2ae514eb141d45774730765c61bb41c0
import  -/  base-4.12.0.0:Control.Monad 07eaec7fd256019b318d048d00f45b1c
import  -/  base-4.12.0.0:Data.Bits 64fdef6c05b11e33e007318d457467e9
import  -/  base-4.12.0.0:Data.Foldable efb37371da929e7bc88d896298d2d979
import  -/  base-4.12.0.0:GHC.Arr ec26aa94fff9ed31a6fa85d884b35f3c
import  -/  base-4.12.0.0:GHC.Base c00b75f0b052d05c55ba6a4dd1c63b26
import  -/  base-4.12.0.0:GHC.Err ea5e313ef4146b40b5d8b27aa168e736
import  -/  base-4.12.0.0:GHC.Exts 5176e66011d4902498d2e6a4020ba73d
import  -/  base-4.12.0.0:GHC.List 4014a3c8a3b7c31c8325f6bcf1feea4a
import  -/  base-4.12.0.0:GHC.Num c2039f03637c68f47b0bbff4c18ec616
import  -/  base-4.12.0.0:GHC.Real af2b985dd29515c375fb78b2c9298d42
import  -/  base-4.12.0.0:Prelude 3c779dfd6448bdd8e234c336802c2acb
addDependentFile "/Users/alexanderkurz/.stack/programs/x86_64-osx/ghc-8.6.4/lib/ghc-8.6.4/include/ghcversion.h" a0ce8aeb7f525f4d70decd6c1d3ca2dd
addDependentFile ".stack-work/dist/x86_64-osx/Cabal-2.4.0.1/build/autogen/cabal_macros.h" ae3a7c442b1d2cc19b91d5dc56c66c54
fixities infixr 9 HappyStk, infixr 9 HappyStk
0a67e3c7f0ed1ea54e817b2b4118f677
  $tc'HappyA# :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11176824687290970358##
                   12843203370288234880##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tc'HappyA#2
                   0#
                   ParLambdaNat.$tc'HappyA#1) -}
4b4c7785650c1cd3e9960e2961363b48
  $tc'HappyA#1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
a99b43ec875db5838f149c118398b9b0
  $tc'HappyA#2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tc'HappyA#3) -}
e14f09925d6bcd714527d7f9aa33f310
  $tc'HappyA#3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'HappyA#"#) -}
60d96aa39a086a46e52b1fd35287fe93
  $tc'HappyCons :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8798176905297002297##
                   1841235117625212422##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tc'HappyCons2
                   0#
                   ParLambdaNat.$tc'HappyCons1) -}
17a6ac07d1e49b46a2e33c95ec8a3677
  $tc'HappyCons1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
5376a71ba7478d80c392651bceed6084
  $tc'HappyCons2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tc'HappyCons3) -}
a645a4db61539d177b77fa4cfcfc3b4a
  $tc'HappyCons3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'HappyCons"#) -}
dd640d90b564dc08ebab59ceafc61132
  $tc'HappyStk :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   8648156413105868187##
                   8949683092317845728##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tc'HappyStk2
                   1#
                   ParLambdaNat.$tc'HappyStk1) -}
80cb7703de42d3b2797d60f94685cf44
  $tc'HappyStk1 :: GHC.Types.KindRep
  {- HasNoCafRefs, Strictness: m4, Inline: [~] -}
0d501ba023d9100370f28f7b8a3afcec
  $tc'HappyStk2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tc'HappyStk3) -}
1646e0b9103fd3b36deea87c80a7fe69
  $tc'HappyStk3 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'HappyStk"#) -}
cd22809ade77bdaaf765ca490c3ecbeb
  $tcHappyAbsSyn :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17914897369945197902##
                   3753609758698298519##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tcHappyAbsSyn1
                   0#
                   GHC.Types.krep$*) -}
2580087d03fdebc2115666aa7b9f6c1a
  $tcHappyAbsSyn1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tcHappyAbsSyn2) -}
24cd4681b31585b4e8bca26398cdec81
  $tcHappyAbsSyn2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HappyAbsSyn"#) -}
96e7442f0ec737c2d9d9cad783960a2f
  $tcHappyAddr :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2624366261470383115##
                   5546434622797744098##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tcHappyAddr1
                   0#
                   GHC.Types.krep$*) -}
42b37978f8347d17b65b91737faca356
  $tcHappyAddr1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tcHappyAddr2) -}
051b0e271bbadde29123b3c2494bf4e2
  $tcHappyAddr2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HappyAddr"#) -}
bee4925c40c85144ce549c1e38e8bb92
  $tcHappyStk :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   16744984142758988557##
                   17662450783069897724##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tcHappyStk1
                   0#
                   GHC.Types.krep$*Arr*) -}
eeee18e9a1a5b4a3eda1ae58e54701be
  $tcHappyStk1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tcHappyStk2) -}
2ea67335b58f26deb7c48ef903748104
  $tcHappyStk2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("HappyStk"#) -}
837e2f429289fffc5bb886ca8e47fbbd
  $tcHappy_IntList :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   7275166663206710713##
                   15292100447495341493##
                   ParLambdaNat.$trModule
                   ParLambdaNat.$tcHappy_IntList1
                   0#
                   GHC.Types.krep$*) -}
0458d15920ae947d02f8cd9bba962efe
  $tcHappy_IntList1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$tcHappy_IntList2) -}
49a142cd0a1e93a614608dc3aed0d4f4
  $tcHappy_IntList2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("Happy_IntList"#) -}
ab2a1fcf307001a0936e04d79d74ad62
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   ParLambdaNat.$trModule3
                   ParLambdaNat.$trModule1) -}
5ea63ea1594ade64f8696b1fa0314459
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$trModule2) -}
0accd84118046f40d2d597957eb8d481
  $trModule2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("ParLambdaNat"#) -}
3c2547f29b51173da7013fc8bc07024e
  $trModule3 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS ParLambdaNat.$trModule4) -}
cf12f06876d926f48a2ce8bb6436525e
  $trModule4 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("LambdaNat-0.1.0.0-4B7roTwwXlI2zWJKCli09t"#) -}
bc30fd54f48dfd7801bd48ee5491e6ce
  $whappyError :: [LexLambdaNat.Token] -> (# GHC.Base.String #)
  {- Arity: 1, Strictness: <L,U>, Inline: [2],
     Unfolding: (\ @ a (w :: [LexLambdaNat.Token]) ->
                 (# GHC.CString.unpackAppendCString#
                      ParLambdaNat.happyError6
                      (let {
                         n :: [GHC.Types.Char]
                         = case w of wild {
                             [] -> GHC.Types.[] @ GHC.Types.Char
                             : ds ds1
                             -> case ds of wild1 {
                                  LexLambdaNat.PT ipv ipv1
                                  -> GHC.CString.unpackAppendCString#
                                       ParLambdaNat.happyError5
                                       (case ipv1 of wild2 {
                                          LexLambdaNat.TS s dt
                                          -> GHC.Base.++ @ GHC.Types.Char s ParLambdaNat.happyError3
                                          LexLambdaNat.TL s
                                          -> GHC.Base.++_$s++
                                               @ GHC.Types.Char
                                               ParLambdaNat.happyError3
                                               GHC.Show.$fShow(,)3
                                               (GHC.Show.showLitString s GHC.Show.$fShow[]1)
                                          LexLambdaNat.TI s
                                          -> GHC.Base.++ @ GHC.Types.Char s ParLambdaNat.happyError3
                                          LexLambdaNat.TV s
                                          -> GHC.Base.++ @ GHC.Types.Char s ParLambdaNat.happyError3
                                          LexLambdaNat.TD s
                                          -> GHC.Base.++ @ GHC.Types.Char s ParLambdaNat.happyError3
                                          LexLambdaNat.TC s
                                          -> GHC.Base.++ @ GHC.Types.Char s ParLambdaNat.happyError3
                                          LexLambdaNat.T_Id s
                                          -> GHC.Base.++
                                               @ GHC.Types.Char
                                               s
                                               ParLambdaNat.happyError3 })
                                  LexLambdaNat.Err ds2
                                  -> case ds1 of wild2 {
                                       [] -> ParLambdaNat.happyError1
                                       : ipv ipv1
                                       -> GHC.CString.unpackAppendCString#
                                            ParLambdaNat.happyError5
                                            (GHC.Base.++
                                               @ GHC.Types.Char
                                               LexLambdaNat.prToken1
                                               ParLambdaNat.happyError3) } } }
                       } in
                       case w of wild {
                         [] -> GHC.Base.++ @ GHC.Types.Char LexLambdaNat.tokenPos1 n
                         : t ds1
                         -> case t of wild1 {
                              LexLambdaNat.PT p ds2
                              -> case p of ww { LexLambdaNat.Pn ww1 ww2 ww3 ->
                                 GHC.Base.++ @ GHC.Types.Char (LexLambdaNat.$wprintPosn ww2 ww3) n }
                              LexLambdaNat.Err p
                              -> case p of ww { LexLambdaNat.Pn ww1 ww2 ww3 ->
                                 GHC.Base.++
                                   @ GHC.Types.Char
                                   (LexLambdaNat.$wprintPosn ww2 ww3)
                                   n } } }) #)) -}
9bff73bb56465f95017abd45e63ba07c
  $whappyExpListPerState :: GHC.Prim.Int# -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S,U>, Inline: -}
674f8eae0477dd0fc4eed8433955d36a
  $whappyFail ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,U><L,U><L,U(U,U)>,
     Inline: [2],
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w of ds {
                   DEFAULT
                   -> ParLambdaNat.happyDoAction_happyDoAction
                        0#
                        w1
                        w2
                        w3
                        (ParLambdaNat.HappyStk
                           @ ParLambdaNat.HappyAbsSyn
                           (GHC.Types.I# ds)
                             `cast`
                           (UnsafeCo representational GHC.Types.Int ParLambdaNat.HappyAbsSyn)
                           w4)
                   0#
                   -> case w4 of wild { ParLambdaNat.HappyStk x ds1 ->
                      case x `cast`
                           (UnsafeCo representational ParLambdaNat.HappyAbsSyn GHC.Types.Int) of wild1 { GHC.Types.I# i ->
                      \ (tks :: [LexLambdaNat.Token]) ->
                      case i of ds2 {
                        DEFAULT
                        -> case ParLambdaNat.$whappyError
                                  @ ParLambdaNat.HappyAbsSyn
                                  (GHC.Types.: @ LexLambdaNat.Token w1 tks) of ww { Unit# ww1 ->
                           ErrM.Bad @ ParLambdaNat.HappyAbsSyn ww1 }
                        12#
                        -> ParLambdaNat.happyError
                             @ ParLambdaNat.HappyAbsSyn
                             tks } } } }) -}
dd7474aaa2537ebaa271a207cf2ae558
  $whappyReduce ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <L,U><L,U><L,1*C1(U(U,U))><S,1*U><L,U><L,U><L,U(U,U)>,
     Inline: [2],
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: GHC.Prim.Int#)
                   (w2 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn)
                   (w3 :: GHC.Prim.Int#)
                   (w4 :: LexLambdaNat.Token)
                   (w5 :: ParLambdaNat.Happy_IntList)
                   (w6 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w3 of ds {
                   DEFAULT
                   -> case ParLambdaNat.happyDrop
                             (GHC.Prim.-# w 1#)
                             w5 of wild { ParLambdaNat.HappyCons st1 ds1 ->
                      case w2 w6 of a { ParLambdaNat.HappyStk ipv ipv1 ->
                      case ParLambdaNat.happyGotoOffsets of wild1 { ParLambdaNat.HappyA# arr ->
                      let {
                        off' :: GHC.Prim.Int# = GHC.Prim.*# st1 2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr off' of wild2 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr
                             (GHC.Prim.+# off' 1#) of wild3 { DEFAULT ->
                      case ParLambdaNat.happyTable of wild4 { ParLambdaNat.HappyA# arr1 ->
                      let {
                        off'1 :: GHC.Prim.Int#
                        = GHC.Prim.*#
                            (GHC.Prim.+#
                               (GHC.Prim.narrow16Int#
                                  (GHC.Prim.word2Int#
                                     (GHC.Prim.or#
                                        (GHC.Prim.uncheckedShiftL#
                                           (GHC.Prim.int2Word# (GHC.Prim.ord# wild3))
                                           8#)
                                        (GHC.Prim.int2Word# (GHC.Prim.ord# wild2)))))
                               w1)
                            2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr1 off'1 of wild5 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr1
                             (GHC.Prim.+# off'1 1#) of wild6 { DEFAULT ->
                      ParLambdaNat.happyDoAction_happyDoAction
                        ds
                        w4
                        (GHC.Prim.narrow16Int#
                           (GHC.Prim.word2Int#
                              (GHC.Prim.or#
                                 (GHC.Prim.uncheckedShiftL#
                                    (GHC.Prim.int2Word# (GHC.Prim.ord# wild6))
                                    8#)
                                 (GHC.Prim.int2Word# (GHC.Prim.ord# wild5)))))
                        wild
                        a } } } } } } } }
                   0#
                   -> case w6 of wild { ParLambdaNat.HappyStk x ds1 ->
                      case x `cast`
                           (UnsafeCo representational ParLambdaNat.HappyAbsSyn GHC.Types.Int) of wild1 { GHC.Types.I# i ->
                      \ (tks :: [LexLambdaNat.Token]) ->
                      case i of ds2 {
                        DEFAULT
                        -> case ParLambdaNat.$whappyError
                                  @ ParLambdaNat.HappyAbsSyn
                                  (GHC.Types.: @ LexLambdaNat.Token w4 tks) of ww { Unit# ww1 ->
                           ErrM.Bad @ ParLambdaNat.HappyAbsSyn ww1 }
                        12#
                        -> ParLambdaNat.happyError
                             @ ParLambdaNat.HappyAbsSyn
                             tks } } } }) -}
5dac7428addcd438f9c826323e9ae620
  $whappySpecReduce_1 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <L,U><L,1*C1(U)><S,1*U><L,U><L,1*U(U,U)><L,U><L,U>,
     Inline: [2],
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: LexLambdaNat.Token)
                   (w4 :: ParLambdaNat.Happy_IntList)
                   (ww :: ParLambdaNat.HappyAbsSyn)
                   (ww1 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w2 of ds {
                   DEFAULT
                   -> case w4 of wild { ParLambdaNat.HappyCons st ds1 ->
                      case ParLambdaNat.happyGotoOffsets of wild1 { ParLambdaNat.HappyA# arr ->
                      let {
                        off' :: GHC.Prim.Int# = GHC.Prim.*# st 2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr off' of wild2 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr
                             (GHC.Prim.+# off' 1#) of wild3 { DEFAULT ->
                      case ParLambdaNat.happyTable of wild4 { ParLambdaNat.HappyA# arr1 ->
                      let {
                        off'1 :: GHC.Prim.Int#
                        = GHC.Prim.*#
                            (GHC.Prim.+#
                               (GHC.Prim.narrow16Int#
                                  (GHC.Prim.word2Int#
                                     (GHC.Prim.or#
                                        (GHC.Prim.uncheckedShiftL#
                                           (GHC.Prim.int2Word# (GHC.Prim.ord# wild3))
                                           8#)
                                        (GHC.Prim.int2Word# (GHC.Prim.ord# wild2)))))
                               w)
                            2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr1 off'1 of wild5 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr1
                             (GHC.Prim.+# off'1 1#) of wild6 { DEFAULT ->
                      ParLambdaNat.happyDoAction_happyDoAction
                        ds
                        w3
                        (GHC.Prim.narrow16Int#
                           (GHC.Prim.word2Int#
                              (GHC.Prim.or#
                                 (GHC.Prim.uncheckedShiftL#
                                    (GHC.Prim.int2Word# (GHC.Prim.ord# wild6))
                                    8#)
                                 (GHC.Prim.int2Word# (GHC.Prim.ord# wild5)))))
                        wild
                        (ParLambdaNat.HappyStk
                           @ ParLambdaNat.HappyAbsSyn
                           (w1 ww)
                           ww1) } } } } } } }
                   0#
                   -> case ww
                             `cast`
                           (UnsafeCo representational ParLambdaNat.HappyAbsSyn GHC.Types.Int) of wild { GHC.Types.I# i ->
                      \ (tks :: [LexLambdaNat.Token]) ->
                      case i of ds1 {
                        DEFAULT
                        -> case ParLambdaNat.$whappyError
                                  @ ParLambdaNat.HappyAbsSyn
                                  (GHC.Types.: @ LexLambdaNat.Token w3 tks) of ww2 { Unit# ww3 ->
                           ErrM.Bad @ ParLambdaNat.HappyAbsSyn ww3 }
                        12#
                        -> ParLambdaNat.happyError @ ParLambdaNat.HappyAbsSyn tks } } }) -}
3925b2b856c8f0cef938d754c4deee07
  $whappySpecReduce_2 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <L,U><L,1*C1(C1(U))><S,1*U><L,U><L,1*U(A,1*U(U,U))><L,U><L,1*U(U,U)>,
     Inline: [2],
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: LexLambdaNat.Token)
                   (w4 :: ParLambdaNat.Happy_IntList)
                   (ww :: ParLambdaNat.HappyAbsSyn)
                   (ww1 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w2 of ds {
                   DEFAULT
                   -> case w4 of wild { ParLambdaNat.HappyCons ds1 sts ->
                      case sts of wild1 { ParLambdaNat.HappyCons st ds2 ->
                      case ww1 of wild2 { ParLambdaNat.HappyStk v2 stk' ->
                      case ParLambdaNat.happyGotoOffsets of wild3 { ParLambdaNat.HappyA# arr ->
                      let {
                        off' :: GHC.Prim.Int# = GHC.Prim.*# st 2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr off' of wild4 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr
                             (GHC.Prim.+# off' 1#) of wild5 { DEFAULT ->
                      case ParLambdaNat.happyTable of wild6 { ParLambdaNat.HappyA# arr1 ->
                      let {
                        off'1 :: GHC.Prim.Int#
                        = GHC.Prim.*#
                            (GHC.Prim.+#
                               (GHC.Prim.narrow16Int#
                                  (GHC.Prim.word2Int#
                                     (GHC.Prim.or#
                                        (GHC.Prim.uncheckedShiftL#
                                           (GHC.Prim.int2Word# (GHC.Prim.ord# wild5))
                                           8#)
                                        (GHC.Prim.int2Word# (GHC.Prim.ord# wild4)))))
                               w)
                            2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr1 off'1 of wild7 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr1
                             (GHC.Prim.+# off'1 1#) of wild8 { DEFAULT ->
                      ParLambdaNat.happyDoAction_happyDoAction
                        ds
                        w3
                        (GHC.Prim.narrow16Int#
                           (GHC.Prim.word2Int#
                              (GHC.Prim.or#
                                 (GHC.Prim.uncheckedShiftL#
                                    (GHC.Prim.int2Word# (GHC.Prim.ord# wild8))
                                    8#)
                                 (GHC.Prim.int2Word# (GHC.Prim.ord# wild7)))))
                        wild1
                        (ParLambdaNat.HappyStk
                           @ ParLambdaNat.HappyAbsSyn
                           (w1 ww v2)
                           stk') } } } } } } } } }
                   0#
                   -> case ww
                             `cast`
                           (UnsafeCo representational ParLambdaNat.HappyAbsSyn GHC.Types.Int) of wild { GHC.Types.I# i ->
                      \ (tks :: [LexLambdaNat.Token]) ->
                      case i of ds1 {
                        DEFAULT
                        -> case ParLambdaNat.$whappyError
                                  @ ParLambdaNat.HappyAbsSyn
                                  (GHC.Types.: @ LexLambdaNat.Token w3 tks) of ww2 { Unit# ww3 ->
                           ErrM.Bad @ ParLambdaNat.HappyAbsSyn ww3 }
                        12#
                        -> ParLambdaNat.happyError @ ParLambdaNat.HappyAbsSyn tks } } }) -}
70a7d2b22fcbc64a7b4673f83ed1b12b
  $whappySpecReduce_3 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <L,U><L,1*C1(C1(C1(U)))><S,1*U><L,U><L,1*U(A,1*U(A,1*U(U,U)))><L,U><L,1*U(U,1*U(U,U))>,
     Inline: [2],
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: LexLambdaNat.Token)
                   (w4 :: ParLambdaNat.Happy_IntList)
                   (ww :: ParLambdaNat.HappyAbsSyn)
                   (ww1 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w2 of ds {
                   DEFAULT
                   -> case w4 of wild { ParLambdaNat.HappyCons ds1 ds2 ->
                      case ds2 of wild1 { ParLambdaNat.HappyCons ds3 sts ->
                      case sts of wild2 { ParLambdaNat.HappyCons st ds4 ->
                      case ww1 of wild3 { ParLambdaNat.HappyStk v2 ds5 ->
                      case ds5 of wild4 { ParLambdaNat.HappyStk v3 stk' ->
                      case ParLambdaNat.happyGotoOffsets of wild5 { ParLambdaNat.HappyA# arr ->
                      let {
                        off' :: GHC.Prim.Int# = GHC.Prim.*# st 2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr off' of wild6 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr
                             (GHC.Prim.+# off' 1#) of wild7 { DEFAULT ->
                      case ParLambdaNat.happyTable of wild8 { ParLambdaNat.HappyA# arr1 ->
                      let {
                        off'1 :: GHC.Prim.Int#
                        = GHC.Prim.*#
                            (GHC.Prim.+#
                               (GHC.Prim.narrow16Int#
                                  (GHC.Prim.word2Int#
                                     (GHC.Prim.or#
                                        (GHC.Prim.uncheckedShiftL#
                                           (GHC.Prim.int2Word# (GHC.Prim.ord# wild7))
                                           8#)
                                        (GHC.Prim.int2Word# (GHC.Prim.ord# wild6)))))
                               w)
                            2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr1 off'1 of wild9 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr1
                             (GHC.Prim.+# off'1 1#) of wild10 { DEFAULT ->
                      ParLambdaNat.happyDoAction_happyDoAction
                        ds
                        w3
                        (GHC.Prim.narrow16Int#
                           (GHC.Prim.word2Int#
                              (GHC.Prim.or#
                                 (GHC.Prim.uncheckedShiftL#
                                    (GHC.Prim.int2Word# (GHC.Prim.ord# wild10))
                                    8#)
                                 (GHC.Prim.int2Word# (GHC.Prim.ord# wild9)))))
                        wild2
                        (ParLambdaNat.HappyStk
                           @ ParLambdaNat.HappyAbsSyn
                           (w1 ww v2 v3)
                           stk') } } } } } } } } } } }
                   0#
                   -> case ww
                             `cast`
                           (UnsafeCo representational ParLambdaNat.HappyAbsSyn GHC.Types.Int) of wild { GHC.Types.I# i ->
                      \ (tks :: [LexLambdaNat.Token]) ->
                      case i of ds1 {
                        DEFAULT
                        -> case ParLambdaNat.$whappyError
                                  @ ParLambdaNat.HappyAbsSyn
                                  (GHC.Types.: @ LexLambdaNat.Token w3 tks) of ww2 { Unit# ww3 ->
                           ErrM.Bad @ ParLambdaNat.HappyAbsSyn ww3 }
                        12#
                        -> ParLambdaNat.happyError @ ParLambdaNat.HappyAbsSyn tks } } }) -}
a96fca4d5a02bd0260e7405dec941515
  newtype HappyAbsSyn = HappyAbsSyn ParLambdaNat.HappyAny
d1d2052324744060e5d4581e42306938
  data HappyAddr = HappyA# GHC.Prim.Addr#
4b4bee95aa6fce1fef0ded3cedaefefc
  type HappyAny = GHC.Types.Any
dedf03cda922e3eeca01cb828be6518a
  data HappyStk a = HappyStk a (ParLambdaNat.HappyStk a)
3b119a6b4c03ee7a8d28b9ce836724d6
  data Happy_IntList
    = HappyCons GHC.Prim.Int# ParLambdaNat.Happy_IntList
720838434ae5ae73489a6e3c82e01cf5
  happyAccept ::
    GHC.Prim.Int#
    -> p1
    -> GHC.Prim.Int#
    -> p2
    -> ParLambdaNat.HappyStk a
    -> b
    -> ErrM.Err a
  {- Arity: 6, HasNoCafRefs,
     Strictness: <S,1*U><L,A><L,A><L,A><S,1*U(U,1*U(U,A))><L,A>m1,
     Unfolding: InlineRule (6, True, False)
                (\ @ p
                   @ p1
                   @ a
                   @ b
                   (ds :: GHC.Prim.Int#)
                   (tk :: p)
                   (st :: GHC.Prim.Int#)
                   (sts :: p1)
                   (ds1 :: ParLambdaNat.HappyStk a)
                   (eta :: b) ->
                 case ds of ds2 {
                   DEFAULT
                   -> case ds1 of wild { ParLambdaNat.HappyStk ans ds3 ->
                      ErrM.Ok @ a ans }
                   0#
                   -> case ds1 of wild { ParLambdaNat.HappyStk ds3 ds4 ->
                      case ds4 of wild1 { ParLambdaNat.HappyStk ans ds5 ->
                      ErrM.Ok @ a ans } } }) -}
6fd5de272914f75d65c49ba809063962
  happyActOffsets :: ParLambdaNat.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: -}
973247ad6eae7e43dc899ca54aab7d35
  happyAdjustOffset :: GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (off :: GHC.Prim.Int#) -> off) -}
009c5102aab7cb842eef1a463662dd59
  happyCheck :: ParLambdaNat.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: -}
c2465b2943f55213b0bfa842efd64302
  happyDefActions :: ParLambdaNat.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: -}
b566245166453423e7d93dcef3f7c6cf
  happyDoAction ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 3, Strictness: <S,U><L,U><S,U>, Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyDoAction_happyDoAction -}
cf92d1608bfaf824b5cc930481c0323f
  happyDoAction_happyDoAction ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 3, Strictness: <S,U><L,U><S,U> -}
62ba0080e48c87a7ed847a2fd949ea36
  happyDoSeq :: a -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><S,1*U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ a @ b (a1 :: a) (b1 :: b) ->
                 case a1 of a2 { DEFAULT -> b1 }) -}
38b07fd0815a9f80986d7ed4c7951f8e
  happyDontSeq :: a -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (a1 :: a) (b1 :: b) -> b1) -}
ea6d854d98409b39a1fd7bd5e8ef55d0
  happyDrop ::
    GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList -> ParLambdaNat.Happy_IntList
  {- Arity: 2, HasNoCafRefs -}
f27fa320ea39244633e59d6d2bd28260
  happyDropStk ::
    GHC.Prim.Int# -> ParLambdaNat.HappyStk a -> ParLambdaNat.HappyStk a
  {- Arity: 2, HasNoCafRefs -}
ba814bd7522b9e56272525615cda51d3
  happyError :: [LexLambdaNat.Token] -> ErrM.Err a
  {- Arity: 1, Strictness: <L,U>m2, Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ @ a (w :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.$whappyError @ a w of ww { Unit# ww1 ->
                 ErrM.Bad @ a ww1 }) -}
0e32fb005976eb1de760f3b062547dfd
  happyError' ::
    ([LexLambdaNat.Token], [GHC.Base.String]) -> ErrM.Err a
  {- Arity: 1, Strictness: <S,1*U(U,A)>m2,
     Unfolding: InlineRule (1, True, False)
                (\ @ a (ds :: ([LexLambdaNat.Token], [GHC.Base.String])) ->
                 case ds of wild { (,) tokens ds1 ->
                 ParLambdaNat.happyError @ a tokens }) -}
d489ca104bf9e953cee3b40c24bb6862
  happyError1 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ParLambdaNat.happyError2) -}
5569ad943dee6f64142259e2f72c02ae
  happyError2 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" due to lexer error"#) -}
eab9c0307e5e275662abcc0b34d2d9e1
  happyError3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString#
                   ParLambdaNat.happyError4) -}
805f970c32364e1f62fa73c7a9a8f457
  happyError4 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("'"#) -}
360273be80c603f7c7d24a8a892e3445
  happyError5 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: (" before `"#) -}
9e616870aed3ab4f19b6bbee92c28f92
  happyError6 :: GHC.Prim.Addr#
  {- HasNoCafRefs, Unfolding: ("syntax error at "#) -}
9981d699692da7713caa8bb4e4b3767d
  happyError_ ::
    [GHC.Base.String]
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> [LexLambdaNat.Token]
    -> ErrM.Err a
  {- Arity: 4, Strictness: <L,A><S,1*U><L,U><L,U>m2,
     Unfolding: InlineRule (4, True, False)
                (\ @ a
                   (explist :: [GHC.Base.String])
                   (ds :: GHC.Prim.Int#)
                   (tk :: LexLambdaNat.Token)
                   (tks :: [LexLambdaNat.Token]) ->
                 case ds of ds1 {
                   DEFAULT
                   -> ParLambdaNat.happyError
                        @ a
                        (GHC.Types.: @ LexLambdaNat.Token tk tks)
                   12# -> ParLambdaNat.happyError @ a tks }) -}
462127a17f60f4bf4668f580cb8e26d4
  happyExpList :: ParLambdaNat.HappyAddr
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (ParLambdaNat.HappyA# ParLambdaNat.happyExpList1) -}
32a89c11326211b6b0c541195a3d2038
  happyExpList1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("\NUL\NUL\\210\n\
                 \\NUL@Z\SOH\NULH)\NUL\NUL)\EOT\NUL \\133\NUL\NUL\EOT\DLE\NUL\\128\\180\STX\NUL\NUL@\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL \\133\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\\210\n\
                 \\NUL\NUL\NUL\NUL\NULH!\NUL\NUL\NUL\EOT\NUL \\173\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\\144B\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL\NUL@\NUL\NUL\NUL\STX\NUL\NUL\NUL\NUL\NUL\NUL\EOT\NUL\NUL\NUL\NUL\NUL\NULH+\NUL\NULi\ENQ\NUL\NUL@\NUL\NUL\NUL\NUL\NUL\\128\\180\STX\NUL\NUL\b\NUL\NUL\\210\n\
                 \\NUL\NUL\NUL\NUL\NUL\NUL\NUL"#) -}
974da0a6fa868248b041621aaf582fa0
  happyExpListPerState :: GHC.Types.Int -> [[GHC.Types.Char]]
  {- Arity: 1, Strictness: <S(S),1*U(U)>, Inline: [0],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: GHC.Types.Int) ->
                 case w of ww { GHC.Types.I# ww1 ->
                 ParLambdaNat.$whappyExpListPerState ww1 }) -}
2df8c93d779c5e18ad3dd4e0a7a1aaa8
  happyFail ::
    [[GHC.Types.Char]]
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 6, Strictness: <L,A><S,1*U><L,U><S,U><L,U><L,U(U,U)>,
     Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyFail_happyFail -}
e5ed1be48b9ef8f8236d75f4a646bbf8
  happyFail_happyFail ::
    [[GHC.Types.Char]]
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 6, Strictness: <L,A><S,1*U><L,U><S,U><L,U><L,U(U,U)>,
     Inline: [2],
     Unfolding: InlineRule (6, True, True)
                (\ (w :: [[GHC.Types.Char]])
                   (w1 :: GHC.Prim.Int#)
                   (w2 :: LexLambdaNat.Token)
                   (w3 :: GHC.Prim.Int#)
                   (w4 :: ParLambdaNat.Happy_IntList)
                   (w5 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 ParLambdaNat.$whappyFail w1 w2 w3 w4 w5) -}
08d4b73e528d7fc361828ddaeaa24e9e
  happyGoto ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 4, Strictness: <S,U><S,U><L,U><S,U>, Inline: -}
059e994ca01d47e885f1b2fae3927864
  happyGotoOffsets :: ParLambdaNat.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: -}
a1ede4fe1902615d1cd9b2e211d2da20
  happyIn10 :: AbsLambdaNat.Id -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Id) -> x)
                  `cast`
                (<AbsLambdaNat.Id>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Id ParLambdaNat.HappyAbsSyn) -}
81499c58a3e92f19510a1eb0c90af462
  happyIn11 :: AbsLambdaNat.Program -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U(U)>m,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Program) -> x)
                  `cast`
                (<AbsLambdaNat.Program>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Program ParLambdaNat.HappyAbsSyn) -}
4b001f59b1d390ec3bab0c0d13f1be7f
  happyIn12 :: AbsLambdaNat.Exp -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Exp) -> x)
                  `cast`
                (<AbsLambdaNat.Exp>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
481e3f2ea7e0f78f49c9887cbd43d268
  happyIn13 :: AbsLambdaNat.Exp -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Exp) -> x)
                  `cast`
                (<AbsLambdaNat.Exp>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
cf11d889e8fa3ec779fd36b3355a32c9
  happyIn14 :: AbsLambdaNat.Exp -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Exp) -> x)
                  `cast`
                (<AbsLambdaNat.Exp>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
fdf8f5e8136e03f1d8e931b7f760a604
  happyIn15 :: AbsLambdaNat.Exp -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Exp) -> x)
                  `cast`
                (<AbsLambdaNat.Exp>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
a8eb3869963210c2e5277730d4d8552d
  happyIn16 :: AbsLambdaNat.Exp -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Exp) -> x)
                  `cast`
                (<AbsLambdaNat.Exp>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
d9e13a9cfdc27bc1f0875e3785f722c0
  happyIn17 :: AbsLambdaNat.Exp -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: AbsLambdaNat.Exp) -> x)
                  `cast`
                (<AbsLambdaNat.Exp>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
7ab672e938ee11121f21b36e6e216020
  happyInTok :: LexLambdaNat.Token -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: LexLambdaNat.Token) -> x)
                  `cast`
                (<LexLambdaNat.Token>_R
                 ->_R UnsafeCo representational LexLambdaNat.Token ParLambdaNat.HappyAbsSyn) -}
82f4f103df5d3247bbe4c5161800a264
  happyLt :: GHC.Prim.Int# -> GHC.Prim.Int# -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S,U><S,U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ (x :: GHC.Prim.Int#) (y :: GHC.Prim.Int#) ->
                 GHC.Prim.tagToEnum# @ GHC.Types.Bool (GHC.Prim.<# x y)) -}
883b50a9f4b952859662f0d2c035e1ae
  happyMonad2Reduce ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
        -> LexLambdaNat.Token -> ErrM.Err ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 8,
     Strictness: <L,U><L,U><L,1*C1(C1(U))><S,1*U><L,U><L,U><L,U><L,U(U,U)>,
     Unfolding: (\ (k :: GHC.Prim.Int#)
                   (nt :: GHC.Prim.Int#)
                   (fn :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                          -> LexLambdaNat.Token -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                   (ds :: GHC.Prim.Int#)
                   (tk :: LexLambdaNat.Token)
                   (st :: GHC.Prim.Int#)
                   (sts :: ParLambdaNat.Happy_IntList)
                   (stk :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case ds of ds1 {
                   DEFAULT
                   -> case ParLambdaNat.happyDrop
                             k
                             (ParLambdaNat.HappyCons
                                st
                                sts) of wild { ParLambdaNat.HappyCons st1 ds2 ->
                      case ParLambdaNat.happyGotoOffsets of wild1 { ParLambdaNat.HappyA# arr ->
                      let {
                        off' :: GHC.Prim.Int# = GHC.Prim.*# st1 2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr off' of wild2 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr
                             (GHC.Prim.+# off' 1#) of wild3 { DEFAULT ->
                      case ParLambdaNat.happyTable of wild4 { ParLambdaNat.HappyA# arr1 ->
                      let {
                        off'1 :: GHC.Prim.Int#
                        = GHC.Prim.*#
                            (GHC.Prim.+#
                               (GHC.Prim.narrow16Int#
                                  (GHC.Prim.word2Int#
                                     (GHC.Prim.or#
                                        (GHC.Prim.uncheckedShiftL#
                                           (GHC.Prim.int2Word# (GHC.Prim.ord# wild3))
                                           8#)
                                        (GHC.Prim.int2Word# (GHC.Prim.ord# wild2)))))
                               nt)
                            2#
                      } in
                      case GHC.Prim.indexCharOffAddr# arr1 off'1 of wild5 { DEFAULT ->
                      case GHC.Prim.indexCharOffAddr#
                             arr1
                             (GHC.Prim.+# off'1 1#) of wild6 { DEFAULT ->
                      let {
                        new_state :: GHC.Prim.Int#
                        = GHC.Prim.narrow16Int#
                            (GHC.Prim.word2Int#
                               (GHC.Prim.or#
                                  (GHC.Prim.uncheckedShiftL#
                                     (GHC.Prim.int2Word# (GHC.Prim.ord# wild6))
                                     8#)
                                  (GHC.Prim.int2Word# (GHC.Prim.ord# wild5))))
                      } in
                      let {
                        drop_stk :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                        = ParLambdaNat.happyDropStk @ ParLambdaNat.HappyAbsSyn k stk
                      } in
                      let {
                        m :: ErrM.Err ParLambdaNat.HappyAbsSyn = fn stk tk
                      } in
                      \ (tks :: [LexLambdaNat.Token]) ->
                      case m of wild7 {
                        ErrM.Ok a1
                        -> ParLambdaNat.happyNewToken
                             new_state
                             wild
                             (ParLambdaNat.HappyStk @ ParLambdaNat.HappyAbsSyn a1 drop_stk)
                             tks
                        ErrM.Bad s -> wild7 } } } } } } } }
                   0#
                   -> ParLambdaNat.happyFail
                        (GHC.Types.[] @ [GHC.Types.Char])
                        0#
                        tk
                        st
                        sts
                        stk }) -}
ac66351218ff4d7fab1e371206eaffa0
  happyMonadReduce ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
        -> LexLambdaNat.Token -> ErrM.Err ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 8,
     Strictness: <L,U><L,U><L,1*C1(C1(U))><S,1*U><L,U><L,U><L,U><L,U(U,U)>,
     Inline: -}
12203e46127f6a3d4ff8b857e0c7ea52
  happyNewToken ::
    GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 4, Strictness: <L,U><L,U><L,U><S,1*U> -}
d4c2aae06d2fe37198e95cd4f76e5429
  happyOut10 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Id
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Id) -}
3ae403e3838d0b1694553619cec439d8
  happyOut11 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Program
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Program) -}
9b5e7253a05c580cd580e68435723ef4
  happyOut12 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp) -}
d3672bc414859458cc31e0608bb9bbcb
  happyOut13 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp) -}
704db6954ae69db8490dc0e666be1b91
  happyOut14 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp) -}
9d8c84c773fc6c5ade3a340d84719cc2
  happyOut15 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp) -}
21634f046c1a7f83bd2116ca77e247ba
  happyOut16 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp) -}
4fdaa7d8f4f9c5438bea675d203ecfe9
  happyOut17 :: ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp) -}
eb463cea19637f10b20c5d199a1b086b
  happyOutTok :: ParLambdaNat.HappyAbsSyn -> LexLambdaNat.Token
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Inline: (sat-args=1),
     Unfolding: InlineRule (1, False, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x)
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational ParLambdaNat.HappyAbsSyn LexLambdaNat.Token) -}
a1763c4e3c0655e176b8ae7ef7a7a44d
  happyParse ::
    GHC.Prim.Int#
    -> [LexLambdaNat.Token] -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 2, Strictness: <S,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (start_state :: GHC.Prim.Int#) ->
                 ParLambdaNat.happyNewToken
                   start_state
                   (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                   (ParLambdaNat.notHappyAtAll
                      @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))) -}
4649ab18297cd367b31bc1e7cfe3816c
  happyReduce ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 8,
     Strictness: <S,U><S,U><L,1*C1(U(U,U))><S,1*U><L,U><L,A><L,U><L,U(U,U)>,
     Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyReduce_happyReduce -}
2f08422c98667c6d371bc2298bccbedf
  happyReduceArr ::
    GHC.Arr.Array
      GHC.Types.Int
      (GHC.Prim.Int#
       -> LexLambdaNat.Token
       -> GHC.Prim.Int#
       -> ParLambdaNat.Happy_IntList
       -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
       -> [LexLambdaNat.Token]
       -> ErrM.Err ParLambdaNat.HappyAbsSyn)
  {- Unfolding: (case GHC.Magic.runRW#
                        @ ('GHC.Types.TupleRep
                             '[ 'GHC.Types.TupleRep '[], 'GHC.Types.LiftedRep])
                        @ (# GHC.Prim.State# GHC.Prim.RealWorld,
                             GHC.Arr.Array
                               GHC.Types.Int
                               (GHC.Prim.Int#
                                -> LexLambdaNat.Token
                                -> GHC.Prim.Int#
                                -> ParLambdaNat.Happy_IntList
                                -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                                -> [LexLambdaNat.Token]
                                -> ErrM.Err ParLambdaNat.HappyAbsSyn) #)
                        ParLambdaNat.happyReduceArr1 of ds1 { (#,#) ipv ipv1 ->
                 ipv1 }) -}
a0e96a726b65630b21078d4c0917bf0b
  happyReduceArr1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld,
          GHC.Arr.Array
            GHC.Types.Int
            (GHC.Prim.Int#
             -> LexLambdaNat.Token
             -> GHC.Prim.Int#
             -> ParLambdaNat.Happy_IntList
             -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
             -> [LexLambdaNat.Token]
             -> ErrM.Err ParLambdaNat.HappyAbsSyn) #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (s1# :: GHC.Prim.State#
                             GHC.Prim.RealWorld)[OneShot] ->
                 case GHC.Prim.newArray#
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        @ GHC.Prim.RealWorld
                        14#
                        (GHC.Arr.arrEleBottom
                           @ (GHC.Prim.Int#
                              -> LexLambdaNat.Token
                              -> GHC.Prim.Int#
                              -> ParLambdaNat.Happy_IntList
                              -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                              -> [LexLambdaNat.Token]
                              -> ErrM.Err ParLambdaNat.HappyAbsSyn))
                        s1# of ds1 { (#,#) ipv ipv1 ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        0#
                        ParLambdaNat.happyReduce_7
                        ipv of s2# { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        1#
                        ParLambdaNat.happyReduce_8
                        s2# of s2#1 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        2#
                        ParLambdaNat.happyReduce_9
                        s2#1 of s2#2 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        3#
                        ParLambdaNat.happyReduce_10
                        s2#2 of s2#3 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        4#
                        ParLambdaNat.happyReduce_11
                        s2#3 of s2#4 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        5#
                        ParLambdaNat.happyReduce_12
                        s2#4 of s2#5 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        6#
                        ParLambdaNat.happyReduce_13
                        s2#5 of s2#6 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        7#
                        ParLambdaNat.happyReduce_14
                        s2#6 of s2#7 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        8#
                        ParLambdaNat.happyReduce_15
                        s2#7 of s2#8 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        9#
                        ParLambdaNat.happyReduce_16
                        s2#8 of s2#9 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        10#
                        ParLambdaNat.happyReduce_17
                        s2#9 of s2#10 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        11#
                        ParLambdaNat.happyReduce_18
                        s2#10 of s2#11 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        12#
                        ParLambdaNat.happyReduce_19
                        s2#11 of s2#12 { DEFAULT ->
                 case GHC.Prim.writeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        13#
                        ParLambdaNat.happyReduce_20
                        s2#12 of s2#13 { DEFAULT ->
                 case GHC.Prim.unsafeFreezeArray#
                        @ GHC.Prim.RealWorld
                        @ (GHC.Prim.Int#
                           -> LexLambdaNat.Token
                           -> GHC.Prim.Int#
                           -> ParLambdaNat.Happy_IntList
                           -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                           -> [LexLambdaNat.Token]
                           -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                        ipv1
                        s2#13 of ds2 { (#,#) ipv2 ipv3 ->
                 (# ipv2,
                    GHC.Arr.Array
                      @ GHC.Types.Int
                      @ (GHC.Prim.Int#
                         -> LexLambdaNat.Token
                         -> GHC.Prim.Int#
                         -> ParLambdaNat.Happy_IntList
                         -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                         -> [LexLambdaNat.Token]
                         -> ErrM.Err ParLambdaNat.HappyAbsSyn)
                      ParLambdaNat.happyReduceArr3
                      ParLambdaNat.happyReduceArr2
                      14#
                      ipv3 #) } } } } } } } } } } } } } } } }) -}
10dc473cc8ac2bc1b73692271e42d15d
  happyReduceArr2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 20#) -}
43d9dd51245b6cb4e3713bff36e9a1f9
  happyReduceArr3 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 7#) -}
63630bcec4745da67c652e1efdfbd480
  happyReduce_1 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (x :: ParLambdaNat.HappyAbsSyn) -> x) -}
a5928b97c3a7390f8ffc6441e99f5f78
  happyReduce_10 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   2#
                   ParLambdaNat.happyReduce_1
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
5e92c3a3db486fe3935a1f1f58cb0556
  happyReduce_11 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,U><L,U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 ParLambdaNat.$whappyReduce
                   8#
                   3#
                   ParLambdaNat.happyReduction_11
                   w
                   w1
                   w3
                   w4) -}
c96e269e6007cc765e0f2557eff7cd80
  happyReduce_12 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   3#
                   ParLambdaNat.happyReduce_1
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
dcec36d920581d3a77114f9e9ec79401
  happyReduce_13 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,A><L,1*U(A,1*U(U,U))><S,1*U(U,1*U(U,U))>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_2
                   4#
                   ParLambdaNat.happyReduce_4
                     `cast`
                   (<ParLambdaNat.HappyAbsSyn>_R
                    ->_R <ParLambdaNat.HappyAbsSyn>_R
                    ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
efb5a8b923b327cf44991db887663d0f
  happyReduce_14 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   4#
                   ParLambdaNat.happyReduce_1
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
89c0e06683d66963bf9e87fb271fe87c
  happyReduce_15 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   5#
                   (ParLambdaNat.happyReduce_3 @ ParLambdaNat.HappyAbsSyn)
                     `cast`
                   (<ParLambdaNat.HappyAbsSyn>_R
                    ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
bd9d35746592b4ac56bfbe6762654225
  happyReduce_16 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,A><L,1*U(A,1*U(U,U))><S,1*U(U,1*U(U,U))>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_2
                   5#
                   (ParLambdaNat.happyReduce_2 @ ParLambdaNat.HappyAbsSyn)
                     `cast`
                   (<ParLambdaNat.HappyAbsSyn>_R
                    ->_R <ParLambdaNat.HappyAbsSyn>_R
                    ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
daaee06845d77570f377f7aee045828f
  happyReduce_17 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   5#
                   ParLambdaNat.happyReduce_1
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
55769f6205b6fb76739779efde1056de
  happyReduce_18 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   6#
                   AbsLambdaNat.EVar
                     `cast`
                   (UnsafeCo representational AbsLambdaNat.Id ParLambdaNat.HappyAbsSyn
                    ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
2a3f71165af5a6bbbe85ca1fcb75bebd
  happyReduce_19 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5,
     Strictness: <S,1*U><L,U><L,A><L,1*U(A,1*U(A,1*U(U,U)))><S,1*U(U,1*U(U,1*U(U,U)))>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_3
                   6#
                   (ParLambdaNat.happyReduction_19
                      @ ParLambdaNat.HappyAbsSyn
                      @ ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
73a6a660411145e2a14202fc29348030
  happyReduce_2 :: ParLambdaNat.HappyAbsSyn -> p -> AbsLambdaNat.Exp
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m5,
     Unfolding: InlineRule (2, True, True)
                (\ @ p (happy_x_2 :: ParLambdaNat.HappyAbsSyn) (happy_x_1 :: p) ->
                 AbsLambdaNat.ENatS
                   happy_x_2
                     `cast`
                   (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)) -}
0aec69c7dca2d261e4922e3791d07c53
  happyReduce_20 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   7#
                   ParLambdaNat.happyReduce_1
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
210b83c82c21bd8a6295c0c23ba14bfc
  happyReduce_3 :: p -> AbsLambdaNat.Exp
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (1, True, True)
                (\ @ p (happy_x_1 :: p) -> AbsLambdaNat.ENat0) -}
d3b8f49892b9f7e4a3e142f09c4639e9
  happyReduce_4 ::
    ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyAbsSyn -> AbsLambdaNat.Exp
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m3,
     Unfolding: InlineRule (2, True, True)
                (\ (happy_x_2 :: ParLambdaNat.HappyAbsSyn)
                   (happy_x_1 :: ParLambdaNat.HappyAbsSyn) ->
                 AbsLambdaNat.EApp
                   happy_x_1
                     `cast`
                   (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   happy_x_2
                     `cast`
                   (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)) -}
e226b8caae0857ea3a8c7aca1aaacddb
  happyReduce_7 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   0#
                   ParLambdaNat.happyReduction_7
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
5187bdf35e49dac5e3da29b2b51755fe
  happyReduce_8 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w4 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1
                   1#
                   AbsLambdaNat.Prog
                     `cast`
                   (UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn
                    ->_R UnsafeCo representational AbsLambdaNat.Program ParLambdaNat.HappyAbsSyn)
                   w
                   w1
                   w3
                   ww1
                   ww2 }) -}
f2935f924f041a7b787506ca30bb0881
  happyReduce_9 ::
    GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 5, Strictness: <S,1*U><L,U><L,A><L,U><L,U(U,U)>,
     Unfolding: (\ (w :: GHC.Prim.Int#)
                   (w1 :: LexLambdaNat.Token)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: ParLambdaNat.Happy_IntList)
                   (w4 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 ParLambdaNat.$whappyReduce
                   4#
                   2#
                   ParLambdaNat.happyReduction_9
                   w
                   w1
                   w3
                   w4) -}
c04a3b6a55d4eca2132ac4bd612c8b70
  happyReduce_happyReduce ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 8,
     Strictness: <S,U><S,U><L,1*C1(U(U,U))><S,1*U><L,U><L,A><L,U><L,U(U,U)>,
     Inline: [2],
     Unfolding: InlineRule (8, True, True)
                (\ (w :: GHC.Prim.Int#)
                   (w1 :: GHC.Prim.Int#)
                   (w2 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn)
                   (w3 :: GHC.Prim.Int#)
                   (w4 :: LexLambdaNat.Token)
                   (w5 :: GHC.Prim.Int#)
                   (w6 :: ParLambdaNat.Happy_IntList)
                   (w7 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 ParLambdaNat.$whappyReduce w w1 w2 w3 w4 w6 w7) -}
17b7fda51ecff753f9f67b79fd942c63
  happyReduction_1 :: GHC.Prim.Addr#
  {- HasNoCafRefs,
     Unfolding: ("src/ParLambdaNat.hs:(137,13)-(140,10)|case"#) -}
0734717713332c9d859f2cdac98d0164
  happyReduction_10 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (happy_x_1 :: ParLambdaNat.HappyAbsSyn) -> happy_x_1) -}
e6743e0c0c8beab114d0572ed641e1f0
  happyReduction_11 ::
    ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LS(LS(LS(LS(LS(LS))))))),1*U(U,1*U(A,1*U(U,1*U(A,1*U(U,1*U(A,1*U(U,1*U(A,U))))))))>m,
     Inline: [2],
     Unfolding: InlineRule (1, True, False)
                (\ (w :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 case ww2 of ww3 { ParLambdaNat.HappyStk ww4 ww5 ->
                 case ww5 of ww6 { ParLambdaNat.HappyStk ww7 ww8 ->
                 case ww8 of ww9 { ParLambdaNat.HappyStk ww10 ww11 ->
                 case ww11 of ww12 { ParLambdaNat.HappyStk ww13 ww14 ->
                 case ww14 of ww15 { ParLambdaNat.HappyStk ww16 ww17 ->
                 case ww17 of ww18 { ParLambdaNat.HappyStk ww19 ww20 ->
                 case ww20 of ww21 { ParLambdaNat.HappyStk ww22 ww23 ->
                 ParLambdaNat.HappyStk
                   @ ParLambdaNat.HappyAbsSyn
                   (AbsLambdaNat.EIf
                      ww19
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                      ww13
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                      ww7
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                      ww1
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp))
                     `cast`
                   (UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   ww23 } } } } } } } }) -}
5f64333a80d4f4a3a7d3d20e4fbc5cd8
  happyReduction_12 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (happy_x_1 :: ParLambdaNat.HappyAbsSyn) -> happy_x_1) -}
41880f0b6b742d0b8131296c90667237
  happyReduction_13 ::
    ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,U>m3,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyReduce_4
                  `cast`
                (<ParLambdaNat.HappyAbsSyn>_R
                 ->_R <ParLambdaNat.HappyAbsSyn>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
87a7effd43547a928a33730758d84fbb
  happyReduction_14 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (happy_x_1 :: ParLambdaNat.HappyAbsSyn) -> happy_x_1) -}
53646e211f305e0fa0fdf4b97fb49b62
  happyReduction_15 :: p -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <L,A>,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyReduce_3
                  `cast`
                (forall (p :: <*>_N).
                 <p>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
a3a59613615850987dad9e45da78d3f2
  happyReduction_16 ::
    ParLambdaNat.HappyAbsSyn -> p -> ParLambdaNat.HappyAbsSyn
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m5,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyReduce_2
                  `cast`
                (forall (p :: <*>_N).
                 <ParLambdaNat.HappyAbsSyn>_R
                 ->_R <p>_R
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
a735b2d4c818167a22df7febcb3511eb
  happyReduction_17 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (happy_x_1 :: ParLambdaNat.HappyAbsSyn) -> happy_x_1) -}
443c7709fb34788aa66c477ae3b18482
  happyReduction_18 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m6,
     Unfolding: InlineRule (0, True, True)
                AbsLambdaNat.EVar
                  `cast`
                (UnsafeCo representational AbsLambdaNat.Id ParLambdaNat.HappyAbsSyn
                 ->_R UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn) -}
969e845522362cf9fce110f607e22d74
  happyReduction_19 ::
    p1 -> ParLambdaNat.HappyAbsSyn -> p2 -> ParLambdaNat.HappyAbsSyn
  {- Arity: 3, HasNoCafRefs, Strictness: <L,A><S,1*U><L,A>,
     Unfolding: InlineRule (3, True, True)
                (\ @ p
                   @ p1
                   (happy_x_3 :: p)
                   (happy_x_2 :: ParLambdaNat.HappyAbsSyn)
                   (happy_x_1 :: p1) ->
                 happy_x_2) -}
efcff1ce841068efcb5d3e1abbb9188e
  happyReduction_20 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ (happy_x_1 :: ParLambdaNat.HappyAbsSyn) -> happy_x_1) -}
40dcab6bde54d5e753a7327f637e2c3f
  happyReduction_7 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (happy_x_1 :: ParLambdaNat.HappyAbsSyn) ->
                 case happy_x_1
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn LexLambdaNat.Token) of wild {
                   LexLambdaNat.PT ds ds1
                   -> case ds1 of wild1 {
                        DEFAULT
                        -> Control.Exception.Base.patError
                             @ 'GHC.Types.LiftedRep
                             @ ParLambdaNat.HappyAbsSyn
                             ParLambdaNat.happyReduction_1
                        LexLambdaNat.T_Id happy_var_1
                        -> happy_var_1
                             `cast`
                           (Sym (AbsLambdaNat.N:Id[0]) ; UnsafeCo representational AbsLambdaNat.Id ParLambdaNat.HappyAbsSyn) }
                   LexLambdaNat.Err ipv
                   -> Control.Exception.Base.patError
                        @ 'GHC.Types.LiftedRep
                        @ ParLambdaNat.HappyAbsSyn
                        ParLambdaNat.happyReduction_1 }) -}
f91cdb67209cdd49d4c784c4ddb903a4
  happyReduction_8 ::
    ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m,
     Unfolding: InlineRule (0, True, True)
                AbsLambdaNat.Prog
                  `cast`
                (UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn
                 ->_R UnsafeCo representational AbsLambdaNat.Program ParLambdaNat.HappyAbsSyn) -}
0f1390ca31e0fbd701eb7b3027cf795d
  happyReduction_9 ::
    ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
  {- Arity: 1, HasNoCafRefs,
     Strictness: <S(LS(LS(LS))),1*U(U,1*U(A,1*U(U,1*U(A,U))))>m,
     Unfolding: InlineRule (1, True, False)
                (\ (ds :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case ds of wild { ParLambdaNat.HappyStk happy_x_4 ds1 ->
                 case ds1 of wild1 { ParLambdaNat.HappyStk happy_x_3 ds2 ->
                 case ds2 of wild2 { ParLambdaNat.HappyStk happy_x_2 ds3 ->
                 case ds3 of wild3 { ParLambdaNat.HappyStk happy_x_1 happyRest ->
                 ParLambdaNat.HappyStk
                   @ ParLambdaNat.HappyAbsSyn
                   (AbsLambdaNat.EAbs
                      happy_x_2
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Id)
                      happy_x_4
                        `cast`
                      (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp))
                     `cast`
                   (UnsafeCo representational AbsLambdaNat.Exp ParLambdaNat.HappyAbsSyn)
                   happyRest } } } }) -}
94fe962a48c8678a271e1e748890937b
  happyReturn :: a -> ErrM.Err a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m1,
     Unfolding: InlineRule (0, True, True) ErrM.Ok -}
73375d56772e2262b8b3e4cd5d9194f7
  happyReturn1 :: a -> b -> ErrM.Err a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><L,A>m1,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (a1 :: a) (tks :: b) -> ErrM.Ok @ a a1) -}
507a5bbce72bc39b4e4c672d22b43974
  happySeq :: a -> b -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (0, True, True) ParLambdaNat.happyDontSeq -}
f0f382cc31c6db712425e154de868eb4
  happyShift ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 6, Strictness: <S,U><S,1*U><L,U><L,U><L,U><L,U(U,U)>,
     Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happyShift_happyShift -}
fbea57751748afc4e1b932633001b361
  happyShift_happyShift ::
    GHC.Prim.Int#
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 6, Strictness: <S,U><S,1*U><L,U><L,U><L,U><L,U(U,U)>,
     Unfolding: (\ (new_state :: GHC.Prim.Int#)
                   (ds :: GHC.Prim.Int#)
                   (tk :: LexLambdaNat.Token)
                   (st :: GHC.Prim.Int#)
                   (sts :: ParLambdaNat.Happy_IntList)
                   (stk :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case ds of ds1 {
                   DEFAULT
                   -> ParLambdaNat.happyNewToken
                        new_state
                        (ParLambdaNat.HappyCons st sts)
                        (ParLambdaNat.HappyStk
                           @ ParLambdaNat.HappyAbsSyn
                           tk
                             `cast`
                           (UnsafeCo representational LexLambdaNat.Token ParLambdaNat.HappyAbsSyn)
                           stk)
                   0#
                   -> case stk of wild { ParLambdaNat.HappyStk x ds2 ->
                      case x `cast`
                           (UnsafeCo representational ParLambdaNat.HappyAbsSyn GHC.Types.Int) of wild1 { GHC.Types.I# i ->
                      ParLambdaNat.happyDoAction_happyDoAction
                        i
                        tk
                        new_state
                        (ParLambdaNat.HappyCons st sts)
                        wild } } }) -}
a4bfdee4364321a415204e0a8ec426f4
  happySpecReduce_0 ::
    GHC.Prim.Int#
    -> ParLambdaNat.HappyAbsSyn
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <L,U><L,U><S,1*U><L,U><S,U><L,U><L,U(U,U)>, Inline: -}
573e0ac67e805b58a0aa73a4bd96e2b8
  happySpecReduce_1 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <S,U><L,1*C1(U)><S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happySpecReduce_1_happySpecReduce_1 -}
173e55efa043c696784981ca1529eb62
  happySpecReduce_1_happySpecReduce_1 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <S,U><L,1*C1(U)><S,1*U><L,U><L,A><L,1*U(U,U)><S,1*U(U,U)>,
     Inline: [2],
     Unfolding: InlineRule (7, True, False)
                (\ (w :: GHC.Prim.Int#)
                   (w1 :: ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: LexLambdaNat.Token)
                   (w4 :: GHC.Prim.Int#)
                   (w5 :: ParLambdaNat.Happy_IntList)
                   (w6 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w6 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_1 w w1 w2 w3 w5 ww1 ww2 }) -}
caf25b735d09c80796e24ab37d8f5c45
  happySpecReduce_2 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <S,U><L,1*C1(C1(U))><S,1*U><L,U><L,A><L,1*U(A,1*U(U,U))><S,1*U(U,1*U(U,U))>,
     Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happySpecReduce_2_happySpecReduce_2 -}
120a5e0f71a066b5eb22d192b2ceebdb
  happySpecReduce_2_happySpecReduce_2 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <S,U><L,1*C1(C1(U))><S,1*U><L,U><L,A><L,1*U(A,1*U(U,U))><S,1*U(U,1*U(U,U))>,
     Inline: [2],
     Unfolding: InlineRule (7, True, False)
                (\ (w :: GHC.Prim.Int#)
                   (w1 :: ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn -> ParLambdaNat.HappyAbsSyn)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: LexLambdaNat.Token)
                   (w4 :: GHC.Prim.Int#)
                   (w5 :: ParLambdaNat.Happy_IntList)
                   (w6 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w6 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_2 w w1 w2 w3 w5 ww1 ww2 }) -}
ea36d50cdcdf0123edc6e9f234f69f07
  happySpecReduce_3 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <S,U><L,1*C1(C1(C1(U)))><S,1*U><L,U><L,A><L,1*U(A,1*U(A,1*U(U,U)))><S,1*U(U,1*U(U,1*U(U,U)))>,
     Inline:,
     Unfolding: InlineRule (0, True, True)
                ParLambdaNat.happySpecReduce_3_happySpecReduce_3 -}
38e34fa94b1101079d19bb7954e35b77
  happySpecReduce_3_happySpecReduce_3 ::
    GHC.Prim.Int#
    -> (ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn
        -> ParLambdaNat.HappyAbsSyn)
    -> GHC.Prim.Int#
    -> LexLambdaNat.Token
    -> GHC.Prim.Int#
    -> ParLambdaNat.Happy_IntList
    -> ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn
    -> [LexLambdaNat.Token]
    -> ErrM.Err ParLambdaNat.HappyAbsSyn
  {- Arity: 7,
     Strictness: <S,U><L,1*C1(C1(C1(U)))><S,1*U><L,U><L,A><L,1*U(A,1*U(A,1*U(U,U)))><S,1*U(U,1*U(U,1*U(U,U)))>,
     Inline: [2],
     Unfolding: InlineRule (7, True, False)
                (\ (w :: GHC.Prim.Int#)
                   (w1 :: ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn
                          -> ParLambdaNat.HappyAbsSyn)
                   (w2 :: GHC.Prim.Int#)
                   (w3 :: LexLambdaNat.Token)
                   (w4 :: GHC.Prim.Int#)
                   (w5 :: ParLambdaNat.Happy_IntList)
                   (w6 :: ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn) ->
                 case w6 of ww { ParLambdaNat.HappyStk ww1 ww2 ->
                 ParLambdaNat.$whappySpecReduce_3 w w1 w2 w3 w5 ww1 ww2 }) -}
7dc2b14baa5dc79f1d0934af006658ad
  happyTable :: ParLambdaNat.HappyAddr
  {- HasNoCafRefs, Strictness: m, Inline: -}
c086883d9ffbe6a7e13672c54593361d
  happyTcHack :: GHC.Prim.Int# -> a -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Inline: (sat-args=2),
     Unfolding: InlineRule (2, False, True)
                (\ @ a (x :: GHC.Prim.Int#) (y :: a) -> y) -}
21ae9e386bf1f223ceca725d6d3aee65
  happyThen :: ErrM.Err a -> (a -> ErrM.Err b) -> ErrM.Err b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True) ErrM.$fMonadErr_$c>>= -}
ff9eb101a00690eb54f8d8a2c5808935
  happyThen1 ::
    ErrM.Err t1 -> (t1 -> t2 -> ErrM.Err b) -> t2 -> ErrM.Err b
  {- Arity: 3, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(C1(U))><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ t
                   @ t1
                   @ b
                   (m :: ErrM.Err t)
                   (k :: t -> t1 -> ErrM.Err b)
                   (tks :: t1) ->
                 case m of wild {
                   ErrM.Ok a1 -> k a1 tks ErrM.Bad s -> ErrM.Bad @ b s }) -}
39a8fb2dce041ee4a35ab3246c60abae
  happy_n_nonterms :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 8#) -}
f160312428ff7b7c01e152b2e05cd6df
  happy_n_terms :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 13#) -}
ef8298cbd575c3d2c6fbace3bb061991
  indexShortOffAddr ::
    ParLambdaNat.HappyAddr -> GHC.Prim.Int# -> GHC.Prim.Int#
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (ds :: ParLambdaNat.HappyAddr) (off :: GHC.Prim.Int#) ->
                 case ds of wild { ParLambdaNat.HappyA# arr ->
                 let {
                   off' :: GHC.Prim.Int# = GHC.Prim.*# off 2#
                 } in
                 case GHC.Prim.indexCharOffAddr# arr off' of wild1 { DEFAULT ->
                 case GHC.Prim.indexCharOffAddr#
                        arr
                        (GHC.Prim.+# off' 1#) of wild2 { DEFAULT ->
                 GHC.Prim.narrow16Int#
                   (GHC.Prim.word2Int#
                      (GHC.Prim.or#
                         (GHC.Prim.uncheckedShiftL#
                            (GHC.Prim.int2Word# (GHC.Prim.ord# wild2))
                            8#)
                         (GHC.Prim.int2Word# (GHC.Prim.ord# wild1)))) } } }) -}
afc3464d813c718b0bd97bcc7c505d5b
  myLexer :: GHC.Base.String -> [LexLambdaNat.Token]
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (0, True, True) LexLambdaNat.tokens -}
771ac3260840ba9ebaf05c5520770569
  notHappyAtAll :: a
  {- Strictness: x -}
d1e39172fab6594b8b4593cb01802f5a
  pExp :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Exp
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        6#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Exp
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Exp s }) -}
3a4dd4bad3805f37281d7fed7bae7013
  pExp1 :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Exp
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        1#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Exp
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Exp s }) -}
76100a49a5ff060da67076782173c426
  pExp2 :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Exp
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        2#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Exp
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Exp s }) -}
be0b222e0594aaf72e60a2dc93f35e57
  pExp3 :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Exp
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        3#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Exp
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Exp s }) -}
376f7d21e0976184207ab80ec1eb309f
  pExp4 :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Exp
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        4#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Exp
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Exp s }) -}
42e18ea96693439c74ab63b8dbb4e9cf
  pExp5 :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Exp
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        5#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Exp
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Exp)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Exp s }) -}
099b41ae962ef6be03e82e2f619c1a82
  pProgram :: [LexLambdaNat.Token] -> ErrM.Err AbsLambdaNat.Program
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: (\ (tks :: [LexLambdaNat.Token]) ->
                 case ParLambdaNat.happyNewToken
                        0#
                        (ParLambdaNat.notHappyAtAll @ ParLambdaNat.Happy_IntList)
                        (ParLambdaNat.notHappyAtAll
                           @ (ParLambdaNat.HappyStk ParLambdaNat.HappyAbsSyn))
                        tks of wild {
                   ErrM.Ok a1
                   -> ErrM.Ok
                        @ AbsLambdaNat.Program
                        a1
                          `cast`
                        (UnsafeCo representational ParLambdaNat.HappyAbsSyn AbsLambdaNat.Program)
                   ErrM.Bad s -> ErrM.Bad @ AbsLambdaNat.Program s }) -}
dbd320b535bcfc2d9a99fa555419c90e
  readArrayBit ::
    ParLambdaNat.HappyAddr -> GHC.Types.Int -> GHC.Types.Bool
  {- Arity: 2, HasNoCafRefs, Strictness: <S(S),1*U(U)><S(S),1*U(U)>,
     Unfolding: InlineRule (2, True, False)
                (\ (arr :: ParLambdaNat.HappyAddr) (bit :: GHC.Types.Int) ->
                 case bit of wild { GHC.Types.I# x ->
                 case arr of wild1 { ParLambdaNat.HappyA# arr1 ->
                 let {
                   off' :: GHC.Prim.Int#
                   = GHC.Prim.*# (GHC.Prim.uncheckedIShiftRA# x 4#) 2#
                 } in
                 case GHC.Prim.indexCharOffAddr# arr1 off' of wild2 { DEFAULT ->
                 case GHC.Prim.indexCharOffAddr#
                        arr1
                        (GHC.Prim.+# off' 1#) of wild3 { DEFAULT ->
                 let {
                   i# :: GHC.Prim.Int# = GHC.Prim.andI# x 15#
                 } in
                 case GHC.Prim.>=# i# 64# of lwild {
                   DEFAULT
                   -> case GHC.Prim.andI#
                             (GHC.Prim.narrow16Int#
                                (GHC.Prim.word2Int#
                                   (GHC.Prim.or#
                                      (GHC.Prim.uncheckedShiftL#
                                         (GHC.Prim.int2Word# (GHC.Prim.ord# wild3))
                                         8#)
                                      (GHC.Prim.int2Word# (GHC.Prim.ord# wild2)))))
                             (GHC.Prim.uncheckedIShiftL# 1# i#) of wild4 {
                        DEFAULT -> GHC.Types.True 0# -> GHC.Types.False }
                   1# -> GHC.Types.False } } } } }) -}
9292982dfea1736c4d4bdcf6df1e4c3e
  returnM :: a -> ErrM.Err a
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m1,
     Unfolding: InlineRule (0, True, True) ErrM.Ok -}
b607324c183ad3a5dda52fc053d09361
  thenM :: ErrM.Err a -> (a -> ErrM.Err b) -> ErrM.Err b
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,1*C1(U)>,
     Unfolding: InlineRule (0, True, True) ErrM.$fMonadErr_$c>>= -}
trusted: none
require own pkg trusted: False
module header:
  Nothing
declaration docs:
arg docs:

